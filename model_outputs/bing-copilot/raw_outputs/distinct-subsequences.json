{
    "Java": "Certainly! Let's explore **10 different implementations** of the `numDistinct` function in Java to solve the problem described in the docstring. The goal is to count the number of distinct subsequences of string `s` that equal string `t`.\n\nBefore we dive into the implementations, let's understand the problem and the given examples:\n\n1. **Problem Statement**:\n   - Given two strings `s` and `t`, find the number of distinct subsequences of `s` that match `t`.\n   - A subsequence of a string is formed by deleting some (or none) of the characters without changing their relative order.\n   - For example, \"ACE\" is a subsequence of \"ABCDE,\" but \"AEC\" is not.\n   - The answer should fit within a 32-bit signed integer.\n\n2. **Examples**:\n   - Example 1:\n     - Input: `s = \"rabbbit\"`, `t = \"rabbit\"`\n     - Output: 3 (Three ways to generate \"rabbit\" from `s`: \"rabbbit,\" \"rabbbit,\" and \"rabbbit\")\n   - Example 2:\n     - Input: `s = \"babgbag\"`, `t = \"bag\"`\n     - Output: 5 (Five ways to generate \"bag\" from `s`: \"babgbag,\" \"babgbag,\" \"babgbag,\" \"babgbag,\" and \"babgbag\")\n\nNow, let's explore different implementations:\n\n1. **Dynamic Programming (DP) Approach** (O(m*n) space):\n   ```java\n   public int numDistinct(String s, String t) {\n       int[][] table = new int[s.length() + 1][t.length() + 1];\n       for (int i = 0; i < s.length(); i++)\n           table[i][0] = 1;\n       for (int i = 1; i <= s.length(); i++) {\n           for (int j = 1; j <= t.length(); j++) {\n               if (s.charAt(i - 1) == t.charAt(j - 1)) {\n                   table[i][j] += table[i - 1][j] + table[i - 1][j - 1];\n               } else {\n                   table[i][j] += table[i - 1][j];\n               }\n           }\n       }\n       return table[s.length()][t.length()];\n   }\n   ```\n   - This DP solution uses O(m*n) space, where `m` is the length of `s`, and `n` is the length of `t`.\n\n2. **Optimized DP Approach** (O(n) space):\n   ```java\n   public int numDistinct(String s, String t) {\n       if (s == null || t == null || t.length() == 0)\n           return 0;\n       int[] dp = new int[t.length()];\n       for (int i = 0; i < s.length(); i++) {\n           char c = s.charAt(i);\n           for (int j = dp.length - 1; j >= 0; j--) {\n               if (c == t.charAt(j)) {\n                   dp[j] = dp[j] + (j != 0 ? dp[j - 1] : 1);\n               }\n           }\n       }\n       return dp[t.length() - 1];\n   }\n   ```\n   - This solution uses only O(n) space.\n\n3. **Recursive Approach**:\n   ```java\n   public int numDistinct(String s, String t) {\n       if (t.isEmpty())\n           return 1;\n       if (s.isEmpty())\n           return 0;\n       int count = 0;\n       if (s.charAt(0) == t.charAt(0))\n           count += numDistinct(s.substring(1), t.substring(1));\n       count += numDistinct(s.substring(1), t);\n       return count;\n   }\n   ```\n\n4. **Memoization (Top-Down DP)**:\n   ```java\n   public int numDistinct(String s, String t) {\n       int[][] memo = new int[s.length()][t.length()];\n       return helper(s, t, 0, 0, memo);\n   }\n\n   private int helper(String s, String t, int i, int j, int[][] memo) {\n       if (j == t.length())\n           return 1;\n       if (i == s.length())\n           return 0;\n       if (memo[i][j] > 0)\n           return memo[i][j];\n       int count = 0;\n       if (s.charAt(i) == t.charAt(j))\n           count += helper(s, t, i + 1, j + 1, memo);\n       count += helper(s, t, i + 1, j, memo);\n       memo[i][j] = count;\n       return count;\n   }\n   ```\n\n5. **Backtracking Approach**:\n\nSource: Conversation with Bing, 19/02/2024\n(1) java - Given a string S and a string T, count the number of distinct .... https://stackoverflow.com/questions/25840739/given-a-string-s-and-a-string-t-count-the-number-of-distinct-subsequences-of-t.\n(2) LeetCode \u2013 Distinct Subsequences Total (Java) \u2013 Program Creek. https://www.programcreek.com/2013/01/leetcode-distinct-subsequences-total-java/.\n(3) LeetCode/NumDistinct.java at master \u00b7 yuzhangcmu/LeetCode. https://github.com/yuzhangcmu/LeetCode/blob/master/dp/NumDistinct.java.\n(4) undefined. http://traceformula.blogspot.com/2015/08/distinct-subsequences.html.\n(5) github.com. https://github.com/LuoYangDxx/Leetcodejava/tree/bc6adbb9b9cb1ec0db82987e589a69c4fb2442d4/DP&Binary%2F115.DistinctSubsequences.java.\n(6) github.com. https://github.com/mhawk12/LeetCode/tree/a12baadfed7da63a9c718e5ddc12bcfa22cb8d4e/DistinctSequences.java.\n(7) github.com. https://github.com/bosswee/LeetcodePractice/tree/60021dc3ccae3ab5debbac7058660e8802e2230c/src%2FDistinctSubsequences.java.\n(8) github.com. https://github.com/manjutapali/practice/tree/396f6e4d605449db01c1da3e9bd23930c88364f4/DP%2FDistinctSubString.java.\n(9) github.com. https://github.com/lucky0604/leetcode-practice/tree/fc4a22ea22dbe82877f45770af8461f1b2e618af/src%2Fmain%2Fjava%2Fcom%2Ffastdata%2Falgorithm%2Feasy%2Fdynamic_programic%2FIsSubsequence.java.\n(10) github.com. https://github.com/hluu/intv-problems/tree/180027d9a57dcf55fb860c1be97cbbc76a4e45fd/leetcode%2Fsrc%2Fmain%2Fjava%2Fmy%2Fleetcode%2Fdifficult%2FDistinctSubsequences.java.\n(11) github.com. https://github.com/CodeChangeTheWorld/website/tree/8a12f096bf1d6fabe3abd453b162d5dd78f184b0/source%2FLeetCode%2FLeetCode-Distinct-Subsequences.md.",
    "Python": "Certainly! Here are **10 different implementations** of the `numDistinct` function in Python that solve the problem outlined in the docstring. Each implementation uses a different approach or algorithm to find the number of distinct subsequences of `s` that equal `t`. I've included comments to explain each approach:\n\n1. **Dynamic Programming (Bottom-Up)**:\n```python\nclass Solution(object):\n    def numDistinct(self, s, t):\n        m, n = len(s), len(t)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n        for i in range(m + 1):\n            dp[i][0] = 1\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n        return dp[m][n]\n```\n\n2. **Memoization (Top-Down)**:\n```python\nclass Solution(object):\n    def numDistinct(self, s, t):\n        memo = {}\n        def dfs(i, j):\n            if j == len(t):\n                return 1\n            if i == len(s):\n                return 0\n            if (i, j) in memo:\n                return memo[(i, j)]\n            if s[i] == t[j]:\n                memo[(i, j)] = dfs(i + 1, j + 1) + dfs(i + 1, j)\n            else:\n                memo[(i, j)] = dfs(i + 1, j)\n            return memo[(i, j)]\n        return dfs(0, 0)\n```\n\n3. **Recursive Approach**:\n```python\nclass Solution(object):\n    def numDistinct(self, s, t):\n        def dfs(i, j):\n            if j == len(t):\n                return 1\n            if i == len(s):\n                return 0\n            if s[i] == t[j]:\n                return dfs(i + 1, j + 1) + dfs(i + 1, j)\n            else:\n                return dfs(i + 1, j)\n        return dfs(0, 0)\n```\n\n4. **Using Counter**:\n```python\nfrom collections import Counter\n\nclass Solution(object):\n    def numDistinct(self, s, t):\n        s_count, t_count = Counter(s), Counter(t)\n        ans = 1\n        for char in t_count:\n            ans *= s_count[char] ** t_count[char]\n        return ans\n```\n\n5. **Using Recursion with Index Pointers**:\n```python\nclass Solution(object):\n    def numDistinct(self, s, t):\n        def dfs(i, j):\n            if j == len(t):\n                return 1\n            if i == len(s):\n                return 0\n            count = 0\n            if s[i] == t[j]:\n                count += dfs(i + 1, j + 1)\n            count += dfs(i + 1, j)\n            return count\n        return dfs(0, 0)\n```\n\n6. **Using 2D Array for Counting**:\n```python\nclass Solution(object):\n    def numDistinct(self, s, t):\n        dp = [[0] * (len(t) + 1) for _ in range(len(s) + 1)]\n        for i in range(len(s) + 1):\n            dp[i][0] = 1\n        for i in range(1, len(s) + 1):\n            for j in range(1, len(t) + 1):\n                dp[i][j] = dp[i - 1][j]\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] += dp[i - 1][j - 1]\n        return dp[len(s)][len(t)]\n```\n\n7. **Using 1D Array for Counting**:\n```python\nclass Solution(object):\n    def numDistinct(self, s, t):\n        dp = [0] * (len(t) + 1)\n        dp[0] = 1\n        for i in range(1, len(s) + 1):\n            for j in range(len(t), 0, -1):\n                if s[i - 1] == t[j - 1]:\n                    dp[j] += dp[j - 1]\n        return dp[len(t)]\n```\n\n8. **Using Iterative Approach**:\n```python\nclass Solution(object):\n    def numDistinct(self, s, t):\n        dp = [0] * (len(t) + 1)\n        dp[0] = 1\n\nSource: Conversation with Bing, 19/02/2024\n(1) github.com. https://github.com/prafulanswer/programming-codes/tree/3efa253f3f4d0aaef220a3e34d4e928fef3a595a/codeforces%2FPracticeDP%2FCount_SubSequence.py.\n(2) github.com. https://github.com/Taoge123/OptimizedLeetcode/tree/24cd6676f32e1cf2bf1f7696f8b736d11507df0e/LeetcodeNew%2FDynamicProgramming%2FLC_115_Distinct_Subsequences.py.\n(3) github.com. https://github.com/zhenxu66/DataStructure/tree/f44a0f4dec854caa675d41bf04e3095e06d79453/leetcode_example%2F115._Distinct_Subsequences.md.\n(4) github.com. https://github.com/PemLer/Journey_of_Algorithm/tree/c0a51f0054446d54f476cf8f1cd3e6268dcd2b35/leetcode%2F101-200%2FT115_numDistinct.py.\n(5) github.com. https://github.com/bgoonz/DATA_STRUC_PYTHON_NOTES/tree/01b47e63b088ad08c135cb96d449a8aeaa8dbc4b/_RESOURCES%2FLEETCODE%2FLeetcode-Lintcode-Python-master%2F115.py.\n(6) github.com. https://github.com/Luolingwei/LeetCode/tree/79d4824879d0faed117eee9d99615cd478432a14/DynamicProgramming%2FQ115_Distinct%20Subsequences.py.\n(7) github.com. https://github.com/therohitsingh/Algo/tree/5f1836184e23daea32013b87d2a6d2599f2fa6d1/LeetCode%2FEasy%2FRecursion&DP%2FCoinChange.py.\n(8) github.com. https://github.com/hansxiao7/leetcode-python/tree/d9f94467491308e22ea0b09195b76b538ba174bc/0392--Is%20Subsequence%2Fsolution1.py.\n(9) github.com. https://github.com/ridersw/Leetcode-Problems/tree/1004c6ddfa156e97e67175bd221e7829223675c5/numDistinct.py.\n(10) github.com. https://github.com/egcode/algorithms-datastructures-patterns/tree/aa807f6b8f1362b6ce4053d8e37b499d1d3d85bc/Patterns%2FLEETCODE%2FAlgorithms%2FDynamicProgramming%2FLongest%20Common%20Subsequence%2FDistinct%20Subsequences.md.\n(11) github.com. https://github.com/tooyoungtoosimplesometimesnaive/probable-octo-potato/tree/696a25f8597e2a5bc5ab788924418d6423160af1/115_distinct_subsequences.py.\n(12) github.com. https://github.com/geemaple/geemaple.github.io/tree/423a3894d138f902df49ba5a1f5c701ad99e1063/_posts%2Fleetcode%2Fleetcode200%2F2021-02-12-leetcode-115.md.\n(13) github.com. https://github.com/huangyingw/leetcode-cli.orig/tree/4c4a969852c51f68ad02f4fafb249229dd4e5a08/submissions%2F115.distinct-subsequences.257436022.Wrong-Answer.leetcode.py.\n(14) github.com. https://github.com/huashiyiqike/Leetcode-Solutions/tree/d2a298ac64d9b58622c221224eb6b269fb42f300/leetcode_py%2FDistinct%20Subsequences.py.\n(15) github.com. https://github.com/oxhead/CodingYourWay/tree/e60ba45fe2f2e5e3b3abfecec3db76f5ce1fde59/src%2Flt_115.py.\n(16) github.com. https://github.com/huangyingw/submissions/tree/63e8db08b03d55789b0b0d5e949d9f07773fe964/115%2F115.distinct-subsequences.208130731.Accepted.leetcode.py.\n(17) github.com. https://github.com/huangyingw/submissions/tree/63e8db08b03d55789b0b0d5e949d9f07773fe964/115%2F115.distinct-subsequences.257435515.Accepted.leetcode.py.\n(18) github.com. https://github.com/huangyingw/submissions/tree/63e8db08b03d55789b0b0d5e949d9f07773fe964/115.distinct-subsequences.208148020.Accepted.leetcode.py.",
    "JavaScript": "Certainly! Let's explore **10 different implementations** of the `numDistinct` function in JavaScript to solve the problem described in the docstring. The goal is to find the number of distinct subsequences of string `s` that equal string `t`.\n\n1. **Recursive Approach with Memoization**:\n```javascript\nvar numDistinct = function(s, t) {\n    const memo = new Map();\n    const helper = (i, j) => {\n        if (j === t.length) return 1;\n        if (i === s.length) return 0;\n        const key = `${i}-${j}`;\n        if (memo.has(key)) return memo.get(key);\n        let count = 0;\n        if (s[i] === t[j]) count += helper(i + 1, j + 1);\n        count += helper(i + 1, j);\n        memo.set(key, count);\n        return count;\n    };\n    return helper(0, 0);\n};\n```\n\n2. **Dynamic Programming (Bottom-Up)**:\n```javascript\nvar numDistinct = function(s, t) {\n    const dp = Array.from({ length: s.length + 1 }, () => Array(t.length + 1).fill(0));\n    for (let i = 0; i <= s.length; i++) dp[i][0] = 1;\n    for (let i = 1; i <= s.length; i++) {\n        for (let j = 1; j <= t.length; j++) {\n            dp[i][j] = dp[i - 1][j];\n            if (s[i - 1] === t[j - 1]) dp[i][j] += dp[i - 1][j - 1];\n        }\n    }\n    return dp[s.length][t.length];\n};\n```\n\n3. **Space-Optimized Dynamic Programming**:\n```javascript\nvar numDistinct = function(s, t) {\n    const dp = Array(t.length + 1).fill(0);\n    dp[0] = 1;\n    for (let i = 1; i <= s.length; i++) {\n        for (let j = t.length; j >= 1; j--) {\n            if (s[i - 1] === t[j - 1]) dp[j] += dp[j - 1];\n        }\n    }\n    return dp[t.length];\n};\n```\n\n4. **Counting Occurrences of Characters in `s` and `t`**:\n```javascript\nvar numDistinct = function(s, t) {\n    const charCount = Array(26).fill(0);\n    for (const char of s) charCount[char.charCodeAt(0) - 97]++;\n    let result = 1;\n    for (const char of t) {\n        const count = charCount[char.charCodeAt(0) - 97];\n        if (count === 0) return 0;\n        result *= count;\n    }\n    return result;\n};\n```\n\n5. **Using a 2D Array to Store Counts**:\n```javascript\nvar numDistinct = function(s, t) {\n    const counts = Array.from({ length: s.length + 1 }, () => Array(t.length + 1).fill(0));\n    for (let i = 0; i <= s.length; i++) counts[i][0] = 1;\n    for (let i = 1; i <= s.length; i++) {\n        for (let j = 1; j <= t.length; j++) {\n            counts[i][j] = counts[i - 1][j];\n            if (s[i - 1] === t[j - 1]) counts[i][j] += counts[i - 1][j - 1];\n        }\n    }\n    return counts[s.length][t.length];\n};\n```\n\n6. **Using a 1D Array to Store Counts**:\n```javascript\nvar numDistinct = function(s, t) {\n    const counts = Array(t.length + 1).fill(0);\n    counts[0] = 1;\n    for (let i = 1; i <= s.length; i++) {\n        for (let j = t.length; j >= 1; j--) {\n            if (s[i - 1] === t[j - 1]) counts[j] += counts[j - 1];\n        }\n    }\n    return counts[t.length];\n};\n```\n\n7. **Using Recursion with Caching**:\n```javascript\nvar numDistinct = function(s, t) {\n    const cache = new Map();\n    const helper = (i, j) => {\n        if (j === t.length) return 1;\n        if (i === s.length) return 0;\n        const key = `${i}-${j}`;\n        if (cache.has(key)) return cache.get(key);\n        let count = 0;\n        if (s[i] === t[j\n\nSource: Conversation with Bing, 19/02/2024\n(1) How might I find the largest number contained in a JavaScript array?. https://stackoverflow.com/questions/1379553/how-might-i-find-the-largest-number-contained-in-a-javascript-array.\n(2) JavaScript Array Distinct (). Ever wanted to get distinct elements .... https://codeburst.io/javascript-array-distinct-5edc93501dc4.\n(3) javascript - Check the equality for each subset of a string S against .... https://codereview.stackexchange.com/questions/187437/check-the-equality-for-each-subset-of-a-string-s-against-the-target-t-and-return.\n(4) github.com. https://github.com/study-player/algorithm/tree/8c3bc4088256e3d2e8a0eae27d289e6455ea45bf/data%2Fdistinct-subsequences%2Fdistinct-subsequences-wu.js.\n(5) github.com. https://github.com/claireli428/Leetcode/tree/e073c1d2b87cfe994629f79718b2720e529652d1/leetcode%2Fdynamic-programming%2F115.%20Distinct%20Subsequences.js.\n(6) github.com. https://github.com/jsyt/blog/tree/ee823615af9839ab41c2c58b4032c3f104514615/content%2Fpost%2Fleetcode115-Distinct-Subsequences.md.\n(7) github.com. https://github.com/vcing/leetcode-ts/tree/4d861593f11f8cfb81c9d4be66f46aa0dab15d5a/src%2F115.distinct-subsequences.js."
}