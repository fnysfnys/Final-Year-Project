{
    "Java": "Here are 10 different Java code snippets to implement the `buildTree` method based on the given docstring:\n\n1. Using Recursion:\n```java\nclass Solution {\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        if (inorder.length == 0 || postorder.length == 0)\n            return null;\n        \n        int rootValue = postorder[postorder.length - 1];\n        TreeNode root = new TreeNode(rootValue);\n\n        int rootIndexInInorder = 0;\n        for (int i = 0; i < inorder.length; i++) {\n            if (inorder[i] == rootValue) {\n                rootIndexInInorder = i;\n                break;\n            }\n        }\n\n        int[] leftInorder = Arrays.copyOfRange(inorder, 0, rootIndexInInorder);\n        int[] leftPostorder = Arrays.copyOfRange(postorder, 0, rootIndexInInorder);\n        int[] rightInorder = Arrays.copyOfRange(inorder, rootIndexInInorder + 1, inorder.length);\n        int[] rightPostorder = Arrays.copyOfRange(postorder, rootIndexInInorder, postorder.length - 1);\n\n        root.left = buildTree(leftInorder, leftPostorder);\n        root.right = buildTree(rightInorder, rightPostorder);\n        \n        return root;\n    }\n}\n```\n\n2. Using HashMap to optimize search in Inorder:\n```java\nclass Solution {\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        Map<Integer, Integer> inorderMap = new HashMap<>();\n        for (int i = 0; i < inorder.length; i++) {\n            inorderMap.put(inorder[i], i);\n        }\n        \n        return buildTreeHelper(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1, inorderMap);\n    }\n    \n    private TreeNode buildTreeHelper(int[] inorder, int inStart, int inEnd, int[] postorder, int postStart, int postEnd, Map<Integer, Integer> inorderMap) {\n        if (inStart > inEnd || postStart > postEnd) {\n            return null;\n        }\n        \n        int rootValue = postorder[postEnd];\n        TreeNode root = new TreeNode(rootValue);\n        int rootIndexInInorder = inorderMap.get(rootValue);\n        int leftSubtreeSize = rootIndexInInorder - inStart;\n        \n        root.left = buildTreeHelper(inorder, inStart, rootIndexInInorder - 1, postorder, postStart, postStart + leftSubtreeSize - 1, inorderMap);\n        root.right = buildTreeHelper(inorder, rootIndexInInorder + 1, inEnd, postorder, postStart + leftSubtreeSize, postEnd - 1, inorderMap);\n        \n        return root;\n    }\n}\n```\n\n3. Using Iteration (Stack) to simulate the recursion:\n```java\nclass Solution {\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        int inLen = inorder.length;\n        int postLen = postorder.length;\n        if (inLen != postLen || inLen == 0) {\n            return null;\n        }\n\n        Map<Integer, Integer> inorderMap = new HashMap<>();\n        for (int i = 0; i < inLen; i++) {\n            inorderMap.put(inorder[i], i);\n        }\n\n        TreeNode root = new TreeNode(postorder[postLen - 1]);\n        Stack<TreeNode> stack = new Stack<>();\n        stack.push(root);\n\n        for (int i = postLen - 2; i >= 0; i--) {\n            int postVal = postorder[i];\n            TreeNode node = stack.peek();\n            if (inorderMap.get(postVal) > inorderMap.get(node.val)) {\n                node.right = new TreeNode(postVal);\n                stack.push(node.right);\n            } else {\n                while (!stack.isEmpty() && inorderMap.get(postVal) < inorderMap.get(stack.peek().val)) {\n                    node = stack.pop();\n                }\n                node.left = new TreeNode(postVal);\n                stack.push(node.left);\n            }\n        }\n\n        return root;\n    }\n}\n```\n\n4. Recursive approach with optimized array copying:\n```java\nclass Solution {\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        return buildTree(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1);\n    }\n\n    private TreeNode buildTree(int[] inorder, int inStart, int inEnd, int[] postorder, int postStart, int postEnd) {\n        if (inStart > inEnd) {\n            return null;\n        }\n\n        int rootValue = postorder[postEnd];\n        TreeNode root = new TreeNode(rootValue);\n        int rootIndexInInorder = inStart;\n\n        while (inorder[rootIndexInInorder] != rootValue) {\n            rootIndexInInorder++;\n        }\n\n        int leftTreeSize = rootIndexInInorder - inStart;\n        root.left = buildTree(inorder, inStart, rootIndexInInorder - 1, postorder, postStart, postStart + leftTreeSize - 1);\n        root.right = buildTree(inorder, rootIndexInInorder + 1, inEnd, postorder, postStart + leftTreeSize, postEnd - 1);\n\n        return root;\n    }\n}\n```\n\n5. Recursive approach with index tracking:\n```java\nclass Solution {\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        return buildTreeHelper(inorder, 0, inorder.length - 1, postorder, 0, postorder.length - 1);\n    }\n\n    private TreeNode buildTreeHelper(int[] inorder, int inStart, int inEnd, int[] postorder, int postStart, int postEnd) {\n        if (inStart > inEnd || postStart > postEnd) {\n            return null;\n        }\n\n        int rootValue = postorder[postEnd];\n        TreeNode root = new TreeNode(rootValue);\n\n        int rootIndex = inStart;\n        while (inorder[rootIndex] != rootValue) {\n            rootIndex++;\n        }\n\n        int leftSubtreeSize = rootIndex - inStart;\n        root.left = buildTreeHelper(inorder, inStart, rootIndex - 1, postorder, postStart, postStart + leftSubtreeSize - 1);\n        root.right = buildTreeHelper(inorder, rootIndex + 1, inEnd, postorder, postStart + leftSubtreeSize, postEnd - 1);\n\n        return root;\n    }\n}\n```\n\n6. Using Recursion with Postorder Index:\n```java\nclass Solution {\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        return buildTreeHelper(inorder, postorder, postorder.length - 1, 0, inorder.length - 1);\n    }\n\n    private TreeNode buildTreeHelper(int[] inorder, int[] postorder, int postIndex, int inStart, int inEnd) {\n        if (inStart > inEnd || postIndex < 0) {\n            return null;\n        }\n\n        int rootValue = postorder[postIndex];\n        TreeNode root = new TreeNode(rootValue);\n\n        int rootIndexInInorder = in\n\nStart;\n        while (inorder[rootIndexInInorder] != rootValue) {\n            rootIndexInInorder++;\n        }\n\n        int rightSubtreeSize = inEnd - rootIndexInInorder;\n        root.right = buildTreeHelper(inorder, postorder, postIndex - 1, rootIndexInInorder + 1, inEnd);\n        root.left = buildTreeHelper(inorder, postorder, postIndex - rightSubtreeSize - 1, inStart, rootIndexInInorder - 1);\n\n        return root;\n    }\n}\n```\n\n7. Recursive approach with Inorder Index:\n```java\nclass Solution {\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        return buildTreeHelper(inorder, postorder, 0, inorder.length - 1, postorder.length - 1);\n    }\n\n    private TreeNode buildTreeHelper(int[] inorder, int[] postorder, int inStart, int inEnd, int postEnd) {\n        if (inStart > inEnd || postEnd < 0) {\n            return null;\n        }\n\n        int rootValue = postorder[postEnd];\n        TreeNode root = new TreeNode(rootValue);\n\n        int rootIndexInInorder = inStart;\n        while (inorder[rootIndexInInorder] != rootValue) {\n            rootIndexInInorder++;\n        }\n\n        int leftSubtreeSize = rootIndexInInorder - inStart;\n        root.left = buildTreeHelper(inorder, postorder, inStart, rootIndexInInorder - 1, postEnd - leftSubtreeSize - 1);\n        root.right = buildTreeHelper(inorder, postorder, rootIndexInInorder + 1, inEnd, postEnd - 1);\n\n        return root;\n    }\n}\n```\n\n8. Recursive approach with Postorder Index (Alternative):\n```java\nclass Solution {\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        return buildTreeHelper(inorder, postorder, postorder.length - 1, 0, inorder.length - 1);\n    }\n\n    private TreeNode buildTreeHelper(int[] inorder, int[] postorder, int postIndex, int inStart, int inEnd) {\n        if (inStart > inEnd || postIndex < 0) {\n            return null;\n        }\n\n        int rootValue = postorder[postIndex];\n        TreeNode root = new TreeNode(rootValue);\n\n        int rootIndexInInorder = inStart;\n        while (inorder[rootIndexInInorder] != rootValue) {\n            rootIndexInInorder++;\n        }\n\n        int rightSubtreeSize = inEnd - rootIndexInInorder;\n        root.right = buildTreeHelper(inorder, postorder, postIndex - 1, rootIndexInInorder + 1, inEnd);\n        root.left = buildTreeHelper(inorder, postorder, postIndex - rightSubtreeSize - 1, inStart, rootIndexInInorder - 1);\n\n        return root;\n    }\n}\n```\n\n9. Recursive approach with Postorder Index and Inorder Index:\n```java\nclass Solution {\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        return buildTreeHelper(inorder, postorder, 0, inorder.length - 1, 0, postorder.length - 1);\n    }\n\n    private TreeNode buildTreeHelper(int[] inorder, int[] postorder, int inStart, int inEnd, int postStart, int postEnd) {\n        if (inStart > inEnd || postStart > postEnd) {\n            return null;\n        }\n\n        int rootValue = postorder[postEnd];\n        TreeNode root = new TreeNode(rootValue);\n\n        int rootIndexInInorder = inStart;\n        while (inorder[rootIndexInInorder] != rootValue) {\n            rootIndexInInorder++;\n        }\n\n        int leftSubtreeSize = rootIndexInInorder - inStart;\n        root.left = buildTreeHelper(inorder, postorder, inStart, rootIndexInInorder - 1, postStart, postStart + leftSubtreeSize - 1);\n        root.right = buildTreeHelper(inorder, postorder, rootIndexInInorder + 1, inEnd, postStart + leftSubtreeSize, postEnd - 1);\n\n        return root;\n    }\n}\n```\n\n10. Recursive approach with Inorder and Postorder Index:\n```java\nclass Solution {\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        return buildTreeHelper(inorder, postorder, 0, inorder.length - 1, 0, postorder.length - 1);\n    }\n\n    private TreeNode buildTreeHelper(int[] inorder, int[] postorder, int inStart, int inEnd, int postStart, int postEnd) {\n        if (inStart > inEnd || postStart > postEnd) {\n            return null;\n        }\n\n        int rootValue = postorder[postEnd];\n        TreeNode root = new TreeNode(rootValue);\n\n        int rootIndexInInorder = inStart;\n        while (inorder[rootIndexInInorder] != rootValue) {\n            rootIndexInInorder++;\n        }\n\n        int rightSubtreeSize = inEnd - rootIndexInInorder;\n        root.right = buildTreeHelper(inorder, postorder, rootIndexInInorder + 1, inEnd, postEnd - rightSubtreeSize, postEnd - 1);\n        root.left = buildTreeHelper(inorder, postorder, inStart, rootIndexInInorder - 1, postStart, postEnd - rightSubtreeSize - 1);\n\n        return root;\n    }\n}\n```\n\nYou can choose any of these implementations based on your preferences or requirements. They all aim to construct a binary tree from the given inorder and postorder traversals.",
    "Python": "Sure, here are 10 different Python code snippets that implement the `buildTree` function based on the provided docstring:\n\n1. Recursive solution:\n```python\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        if not inorder:\n            return None\n        root_val = postorder.pop()\n        root = TreeNode(root_val)\n        root_index = inorder.index(root_val)\n        root.right = self.buildTree(inorder[root_index + 1:], postorder)\n        root.left = self.buildTree(inorder[:root_index], postorder)\n        return root\n```\n\n2. Using a helper function:\n```python\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        def build(in_start, in_end, post_start, post_end):\n            if in_start > in_end:\n                return None\n            root_val = postorder[post_end]\n            root = TreeNode(root_val)\n            root_index = inorder.index(root_val)\n            root.left = build(in_start, root_index - 1, post_start, post_start + root_index - in_start - 1)\n            root.right = build(root_index + 1, in_end, post_start + root_index - in_start, post_end - 1)\n            return root\n        \n        return build(0, len(inorder) - 1, 0, len(postorder) - 1)\n```\n\n3. Using a stack:\n```python\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        if not inorder:\n            return None\n        root = TreeNode(postorder[-1])\n        stack = [(root, inorder, postorder)]\n        while stack:\n            node, in_order, post_order = stack.pop()\n            root_val = post_order.pop()\n            root_index = in_order.index(root_val)\n            if root_index + 1 < len(in_order):\n                node.right = TreeNode(post_order[-1])\n                stack.append((node.right, in_order[root_index + 1:], post_order))\n            if root_index > 0:\n                node.left = TreeNode(post_order[-1])\n                stack.append((node.left, in_order[:root_index], post_order))\n        return root\n```\n\n4. Iterative solution without using indices:\n```python\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        if not inorder:\n            return None\n        root = TreeNode(postorder.pop())\n        stack = [(root, inorder)]\n        while stack:\n            node, in_order = stack.pop()\n            root_val = postorder[-1]\n            root_index = in_order.index(root_val)\n            node.right = TreeNode(postorder.pop())\n            if root_index + 1 < len(in_order):\n                stack.append((node.right, in_order[root_index + 1:]))\n            node.left = TreeNode(postorder.pop())\n            if root_index > 0:\n                stack.append((node.left, in_order[:root_index]))\n        return root\n```\n\n5. Using dictionaries for faster lookup:\n```python\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        inorder_dict = {val: idx for idx, val in enumerate(inorder)}\n        post_idx = [len(postorder) - 1]\n        \n        def build(in_start, in_end):\n            if in_start > in_end:\n                return None\n            root_val = postorder[post_idx[0]]\n            root = TreeNode(root_val)\n            post_idx[0] -= 1\n            root_index = inorder_dict[root_val]\n            root.right = build(root_index + 1, in_end)\n            root.left = build(in_start, root_index - 1)\n            return root\n        \n        return build(0, len(inorder) - 1)\n```\n\n6. Using slices and pop method:\n```python\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        if not inorder:\n            return None\n        root_val = postorder.pop()\n        root = TreeNode(root_val)\n        root_index = inorder.index(root_val)\n        root.right = self.buildTree(inorder[root_index + 1:], postorder)\n        root.left = self.buildTree(inorder[:root_index], postorder)\n        return root\n```\n\n7. Using reverse order and deque:\n```python\nfrom collections import deque\n\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        inorder.reverse()\n        postorder.reverse()\n        inorder = deque(inorder)\n        postorder = deque(postorder)\n        \n        def build(inorder):\n            if not inorder:\n                return None\n            root_val = postorder.popleft()\n            root = TreeNode(root_val)\n            root_index = inorder.index(root_val)\n            root.right = build(inorder[root_index + 1:])\n            root.left = build(inorder[:root_index])\n            return root\n        \n        return build(inorder)\n```\n\n8. Using a list as a stack:\n```python\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        if not inorder:\n            return None\n        root = TreeNode(postorder[-1])\n        stack = [(root, inorder, postorder)]\n        while stack:\n            node, in_order, post_order = stack.pop()\n            root_val = post_order.pop()\n            root_index = in_order.index(root_val)\n            if root_index + 1 < len(in_order):\n                node.right = TreeNode(post_order[-1])\n                stack.append((node.right, in_order[root_index + 1:], post_order))\n            if root_index > 0:\n                node.left = TreeNode(post_order[-1])\n                stack.append((node.left, in_order[:root_index], post_order))\n        return root\n```\n\n9. Using a dictionary to store indices:\n```python\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        inorder_indices = {val: idx for idx, val in enumerate(inorder)}\n        \n        def build(in_start, in_end, post_start, post_end):\n            if in_start > in_end:\n                return None\n            root_val = postorder[post_end]\n            root = TreeNode(root_val)\n            root_index = inorder_indices[root_val]\n            num_right = in_end - root_index\n            root.left = build(in_start, root_index - 1, post_start, post_end - num_right - 1)\n            root.right = build(root_index + 1, in_end, post_start + num_right, post_end - 1)\n            return root\n        \n        return build(0, len(inorder) - 1, 0, len(postorder) - 1)\n```\n\n10. Using a helper function and slices:\n```python\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        def build(in_start, in_end, post_start, post_end):\n            if in_start > in_end:\n                return None\n            root_val = postorder[post_end]\n            root = TreeNode(root_val)\n            root_index = inorder.index(root_val)\n            num_right = in_end - root_index\n            root.left = build(in_start, root_index - 1, post_start, post_start + root_index - in_start - 1)\n            root.right = build(root_index + 1, in_end, post_start + root_index - in_start, post_end - 1)\n            return root\n        \n        return build(0, len(inorder) - 1, \n\n0, len(postorder) - 1)\n```",
    "JavaScript": "Here are 10 different JavaScript code snippets for the `buildTree` function based on the provided docstring:\n\n1. Construct a binary tree recursively using the `inorder` and `postorder` arrays:\n```javascript\nvar buildTree = function(inorder, postorder) {\n    if (inorder.length === 0) return null;\n    \n    const rootVal = postorder.pop();\n    const root = new TreeNode(rootVal);\n    \n    const rootIndexInorder = inorder.indexOf(rootVal);\n    \n    root.right = buildTree(inorder.slice(rootIndexInorder + 1), postorder);\n    root.left = buildTree(inorder.slice(0, rootIndexInorder), postorder);\n    \n    return root;\n};\n```\n\n2. Create a map to optimize the search in `inorder`:\n```javascript\nvar buildTree = function(inorder, postorder) {\n    const indexMap = new Map();\n    inorder.forEach((val, index) => indexMap.set(val, index));\n    \n    const build = (left, right) => {\n        if (left > right) return null;\n        \n        const rootVal = postorder.pop();\n        const root = new TreeNode(rootVal);\n        const inorderIndex = indexMap.get(rootVal);\n        \n        root.right = build(inorderIndex + 1, right);\n        root.left = build(left, inorderIndex - 1);\n        \n        return root;\n    };\n    \n    return build(0, inorder.length - 1);\n};\n```\n\n3. Using two pointers to keep track of `inorder` and `postorder` arrays:\n```javascript\nvar buildTree = function(inorder, postorder) {\n    const build = (inLeft, inRight, postLeft, postRight) => {\n        if (inLeft > inRight) return null;\n        \n        const rootVal = postorder[postRight];\n        const root = new TreeNode(rootVal);\n        const inorderIndex = inorder.indexOf(rootVal);\n        const leftTreeSize = inorderIndex - inLeft;\n        \n        root.left = build(inLeft, inorderIndex - 1, postLeft, postLeft + leftTreeSize - 1);\n        root.right = build(inorderIndex + 1, inRight, postLeft + leftTreeSize, postRight - 1);\n        \n        return root;\n    };\n    \n    return build(0, inorder.length - 1, 0, postorder.length - 1);\n};\n```\n\n4. Using a helper function to simplify the code:\n```javascript\nvar buildTree = function(inorder, postorder) {\n    const build = (inStart, inEnd, postStart, postEnd) => {\n        if (inStart > inEnd) return null;\n        \n        const rootVal = postorder[postEnd];\n        const root = new TreeNode(rootVal);\n        const rootIndex = inorder.indexOf(rootVal);\n        const rightTreeSize = inEnd - rootIndex;\n        \n        root.left = build(inStart, rootIndex - 1, postStart, postEnd - rightTreeSize - 1);\n        root.right = build(rootIndex + 1, inEnd, postEnd - rightTreeSize, postEnd - 1);\n        \n        return root;\n    };\n    \n    return build(0, inorder.length - 1, 0, postorder.length - 1);\n};\n```\n\n5. Using a stack to build the tree iteratively:\n```javascript\nvar buildTree = function(inorder, postorder) {\n    if (inorder.length === 0) return null;\n    \n    const rootVal = postorder.pop();\n    const root = new TreeNode(rootVal);\n    const stack = [];\n    stack.push(root);\n    \n    for (let i = inorder.length - 1; i >= 0; i--) {\n        let currentNode = stack[stack.length - 1];\n        let inorderIndex = inorder.indexOf(currentNode.val);\n        \n        while (inorderIndex !== i) {\n            const newNode = new TreeNode(postorder.pop());\n            currentNode.right = newNode;\n            stack.push(newNode);\n            currentNode = newNode;\n            inorderIndex = inorder.indexOf(currentNode.val);\n        }\n        \n        currentNode.left = new TreeNode(postorder.pop());\n        stack.push(currentNode.left);\n    }\n    \n    return root;\n};\n```\n\n6. Using a helper function and recursive approach with pointers:\n```javascript\nvar buildTree = function(inorder, postorder) {\n    const build = (inStart, inEnd, postStart, postEnd) => {\n        if (inStart > inEnd) return null;\n        \n        const rootVal = postorder[postEnd];\n        const root = new TreeNode(rootVal);\n        const rootIndex = inorder.indexOf(rootVal);\n        const rightTreeSize = inEnd - rootIndex;\n        \n        root.right = build(rootIndex + 1, inEnd, postEnd - rightTreeSize, postEnd - 1);\n        root.left = build(inStart, rootIndex - 1, postStart, postEnd - rightTreeSize - 1);\n        \n        return root;\n    };\n    \n    return build(0, inorder.length - 1, 0, postorder.length - 1);\n};\n```\n\n7. Using a recursive approach with pointers and slices:\n```javascript\nvar buildTree = function(inorder, postorder) {\n    if (inorder.length === 0) return null;\n    \n    const rootVal = postorder.pop();\n    const root = new TreeNode(rootVal);\n    const rootIndexInorder = inorder.indexOf(rootVal);\n    \n    root.right = buildTree(inorder.slice(rootIndexInorder + 1), postorder);\n    root.left = buildTree(inorder.slice(0, rootIndexInorder), postorder);\n    \n    return root;\n};\n```\n\n8. Recursive approach without popping from `postorder`:\n```javascript\nvar buildTree = function(inorder, postorder) {\n    const build = (inStart, inEnd, postStart, postEnd) => {\n        if (inStart > inEnd) return null;\n        \n        const rootVal = postorder[postEnd];\n        const root = new TreeNode(rootVal);\n        const rootIndex = inorder.indexOf(rootVal);\n        const leftTreeSize = rootIndex - inStart;\n        \n        root.left = build(inStart, rootIndex - 1, postStart, postStart + leftTreeSize - 1);\n        root.right = build(rootIndex + 1, inEnd, postStart + leftTreeSize, postEnd - 1);\n        \n        return root;\n    };\n    \n    return build(0, inorder.length - 1, 0, postorder.length - 1);\n};\n```\n\n9. Using a helper function and recursive approach with pointers and slices:\n```javascript\nvar buildTree = function(inorder, postorder) {\n    const build = (inStart, inEnd, postStart, postEnd) => {\n        if (inStart > inEnd) return null;\n        \n        const rootVal = postorder[postEnd];\n        const root = new TreeNode(rootVal);\n        const rootIndexInorder = inorder.indexOf(rootVal);\n        const leftTreeSize = rootIndexInorder - inStart;\n        \n        root.left = build(inStart, rootIndexInorder - 1, postStart, postStart + leftTreeSize - 1);\n        root.right = build(rootIndexInorder + 1, inEnd,\n\n postStart + leftTreeSize, postEnd - 1);\n        \n        return root;\n    };\n    \n    return build(0, inorder.length - 1, 0, postorder.length - 1);\n};\n```\n\n10. Using a recursive approach with pointers and explicit ranges:\n```javascript\nvar buildTree = function(inorder, postorder) {\n    const build = (inStart, inEnd, postStart, postEnd) => {\n        if (inStart > inEnd) return null;\n        \n        const rootVal = postorder[postEnd];\n        const root = new TreeNode(rootVal);\n        const rootIndex = inorder.indexOf(rootVal);\n        \n        root.right = build(rootIndex + 1, inEnd, postStart + rootIndex - inStart, postEnd - 1);\n        root.left = build(inStart, rootIndex - 1, postStart, postStart + rootIndex - inStart - 1);\n        \n        return root;\n    };\n    \n    return build(0, inorder.length - 1, 0, postorder.length - 1);\n};\n```\n\nThese code snippets demonstrate different ways to construct a binary tree from the given `inorder` and `postorder` arrays, as described in the provided docstring. You can choose the one that best suits your coding style and preferences."
}