{
    "Java": "Here are 10 different Java code snippets for the `numDistinct` method based on the provided docstring:\n\n1. Using Dynamic Programming (Bottom-Up Approach):\n```java\npublic int numDistinct(String s, String t) {\n    int m = s.length();\n    int n = t.length();\n\n    int[][] dp = new int[m + 1][n + 1];\n\n    for (int i = 0; i <= m; i++) {\n        dp[i][0] = 1;\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (s.charAt(i - 1) == t.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            } else {\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n```\n\n2. Using Recursion with Memoization:\n```java\npublic int numDistinct(String s, String t) {\n    int m = s.length();\n    int n = t.length();\n    int[][] memo = new int[m + 1][n + 1];\n    return countDistinctSubsequences(s, t, m, n, memo);\n}\n\nprivate int countDistinctSubsequences(String s, String t, int m, int n, int[][] memo) {\n    if (n == 0) {\n        return 1;\n    }\n    if (m == 0) {\n        return 0;\n    }\n\n    if (memo[m][n] != 0) {\n        return memo[m][n];\n    }\n\n    int result = 0;\n    if (s.charAt(m - 1) == t.charAt(n - 1)) {\n        result += countDistinctSubsequences(s, t, m - 1, n - 1, memo);\n    }\n    result += countDistinctSubsequences(s, t, m - 1, n, memo);\n\n    memo[m][n] = result;\n    return result;\n}\n```\n\n3. Using a 1D DP Array:\n```java\npublic int numDistinct(String s, String t) {\n    int m = s.length();\n    int n = t.length();\n\n    int[] dp = new int[n + 1];\n    dp[0] = 1;\n\n    for (int i = 1; i <= m; i++) {\n        int prev = dp[0];\n        for (int j = 1; j <= n; j++) {\n            int temp = dp[j];\n            if (s.charAt(i - 1) == t.charAt(j - 1)) {\n                dp[j] += prev;\n            }\n            prev = temp;\n        }\n    }\n\n    return dp[n];\n}\n```\n\n4. Using a 2D DP Array (Space-Optimized):\n```java\npublic int numDistinct(String s, String t) {\n    int m = s.length();\n    int n = t.length();\n\n    int[] dp = new int[n + 1];\n    dp[0] = 1;\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = n; j >= 1; j--) {\n            if (s.charAt(i - 1) == t.charAt(j - 1)) {\n                dp[j] += dp[j - 1];\n            }\n        }\n    }\n\n    return dp[n];\n}\n```\n\n5. Using a Recursive Approach:\n```java\npublic int numDistinct(String s, String t) {\n    return countDistinctSubsequences(s, t, 0, 0);\n}\n\nprivate int countDistinctSubsequences(String s, String t, int sIndex, int tIndex) {\n    if (tIndex == t.length()) {\n        return 1;\n    }\n    if (sIndex == s.length()) {\n        return 0;\n    }\n\n    int count = 0;\n    if (s.charAt(sIndex) == t.charAt(tIndex)) {\n        count += countDistinctSubsequences(s, t, sIndex + 1, tIndex + 1);\n    }\n    count += countDistinctSubsequences(s, t, sIndex + 1, tIndex);\n\n    return count;\n}\n```\n\n6. Using Iterative Approach (Brute Force):\n```java\npublic int numDistinct(String s, String t) {\n    return countDistinctSubsequences(s, t, 0, 0);\n}\n\nprivate int countDistinctSubsequences(String s, String t, int sIndex, int tIndex) {\n    if (tIndex == t.length()) {\n        return 1;\n    }\n    if (sIndex == s.length()) {\n        return 0;\n    }\n\n    int count = 0;\n    if (s.charAt(sIndex) == t.charAt(tIndex)) {\n        count += countDistinctSubsequences(s, t, sIndex + 1, tIndex + 1);\n    }\n    count += countDistinctSubsequences(s, t, sIndex + 1, tIndex);\n\n    return count;\n}\n```\n\n7. Using a Recursive Approach with Memoization:\n```java\npublic int numDistinct(String s, String t) {\n    int[][] memo = new int[s.length()][t.length()];\n    for (int[] row : memo) {\n        Arrays.fill(row, -1);\n    }\n    return countDistinctSubsequences(s, t, 0, 0, memo);\n}\n\nprivate int countDistinctSubsequences(String s, String t, int sIndex, int tIndex, int[][] memo) {\n    if (tIndex == t.length()) {\n        return 1;\n    }\n    if (sIndex == s.length()) {\n        return 0;\n    }\n\n    if (memo[sIndex][tIndex] != -1) {\n        return memo[sIndex][tIndex];\n    }\n\n    int count = 0;\n    if (s.charAt(sIndex) == t.charAt(tIndex)) {\n        count += countDistinctSubsequences(s, t, sIndex + 1, tIndex + 1, memo);\n    }\n    count += countDistinctSubsequences(s, t, sIndex + 1, tIndex, memo);\n\n    memo[sIndex][tIndex] = count;\n    return count;\n}\n```\n\n8. Using a Recursive Approach with Memoization (Alternative):\n```java\npublic int numDistinct(String s, String t) {\n    int[][] memo = new int[s.length() + 1][t.length() + 1];\n    for (int[] row : memo) {\n        Arrays.fill(row, -1);\n    }\n    return countDistinctSubsequences(s, t, s.length(), t.length(), memo);\n}\n\nprivate int countDistinctSubsequences(String s, String t, int m, int n, int[][] memo) {\n    if (n == 0) {\n        return 1;\n    }\n    if (m == 0) {\n        return 0;\n    }\n\n    if (memo[m][n] != -1) {\n        return memo[m][n];\n    }\n\n    int count = 0;\n    if (s.charAt(m - 1) == t.charAt(n - 1)) {\n        count += countDistinctSubsequences(s, t, m - \n\n1, n - 1, memo);\n    }\n    count += countDistinctSubsequences(s, t, m - 1, n, memo);\n\n    memo[m][n] = count;\n    return count;\n}\n```\n\n9. Using Iterative Approach (Brute Force with Stack):\n```java\npublic int numDistinct(String s, String t) {\n    int count = 0;\n    Stack<Integer> stack = new Stack<>();\n    stack.push(0);\n\n    while (!stack.isEmpty()) {\n        int sIndex = stack.pop();\n        int tIndex = stack.size();\n\n        if (tIndex == t.length()) {\n            count++;\n        } else if (sIndex < s.length()) {\n            if (s.charAt(sIndex) == t.charAt(tIndex)) {\n                stack.push(sIndex + 1);\n                stack.push(sIndex + 1);\n            } else {\n                stack.push(sIndex + 1);\n            }\n        }\n    }\n\n    return count;\n}\n```\n\n10. Using a Recursive Approach (Alternative):\n```java\npublic int numDistinct(String s, String t) {\n    int m = s.length();\n    int n = t.length();\n    if (m < n) {\n        return 0;\n    }\n    if (n == 0) {\n        return 1;\n    }\n\n    int count = 0;\n    if (s.charAt(m - 1) == t.charAt(n - 1)) {\n        count += numDistinct(s.substring(0, m - 1), t.substring(0, n - 1));\n    }\n    count += numDistinct(s.substring(0, m - 1), t);\n\n    return count;\n}\n```\n\nPlease note that some of these code snippets use dynamic programming and memoization for efficiency, while others use recursive or iterative approaches for simplicity. You can choose the one that best suits your requirements and coding style.",
    "Python": "Here are 10 different Python code snippets based on the provided docstring for the `numDistinct` method:\n\n1. Using dynamic programming (bottom-up approach):\n\n```python\nclass Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        Given two strings s and t, return the number of distinct subsequences of s which equals t.\n        The test cases are generated so that the answer fits on a 32-bit signed integer.\n        ...\n        \"\"\"\n        m, n = len(s), len(t)\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        for i in range(m + 1):\n            dp[i][0] = 1\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n                else:\n                    dp[i][j] = dp[i - 1][j]\n\n        return dp[m][n]\n```\n\n2. Using recursion:\n\n```python\nclass Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        Given two strings s and t, return the number of distinct subsequences of s which equals t.\n        The test cases are generated so that the answer fits on a 32-bit signed integer.\n        ...\n        \"\"\"\n        if not t:\n            return 1\n        if not s:\n            return 0\n        if s[-1] == t[-1]:\n            return self.numDistinct(s[:-1], t[:-1]) + self.numDistinct(s[:-1], t)\n        else:\n            return self.numDistinct(s[:-1], t)\n```\n\n3. Using memoization:\n\n```python\nclass Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        Given two strings s and t, return the number of distinct subsequences of s which equals t.\n        The test cases are generated so that the answer fits on a 32-bit signed integer.\n        ...\n        \"\"\"\n        memo = {}\n        \n        def dp(i, j):\n            if j == len(t):\n                return 1\n            if i == len(s):\n                return 0\n            if (i, j) in memo:\n                return memo[(i, j)]\n            \n            if s[i] == t[j]:\n                memo[(i, j)] = dp(i + 1, j + 1) + dp(i + 1, j)\n            else:\n                memo[(i, j)] = dp(i + 1, j)\n            \n            return memo[(i, j)]\n        \n        return dp(0, 0)\n```\n\n4. Using a 1D list for dynamic programming:\n\n```python\nclass Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        Given two strings s and t, return the number of distinct subsequences of s which equals t.\n        The test cases are generated so that the answer fits on a 32-bit signed integer.\n        ...\n        \"\"\"\n        m, n = len(s), len(t)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n\n        for i in range(1, m + 1):\n            for j in range(n, 0, -1):\n                if s[i - 1] == t[j - 1]:\n                    dp[j] += dp[j - 1]\n\n        return dp[n]\n```\n\n5. Using a 2D list with rolling arrays:\n\n```python\nclass Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        Given two strings s and t, return the number of distinct subsequences of s which equals t.\n        The test cases are generated so that the answer fits on a 32-bit signed integer.\n        ...\n        \"\"\"\n        m, n = len(s), len(t)\n        dp = [[0] * (n + 1) for _ in range(2)]\n        dp[0][0] = 1\n\n        for i in range(1, m + 1):\n            dp[i % 2][0] = 1\n            for j in range(1, n + 1):\n                if s[i - 1] == t[j - 1]:\n                    dp[i % 2][j] = dp[(i - 1) % 2][j - 1] + dp[(i - 1) % 2][j]\n                else:\n                    dp[i % 2][j] = dp[(i - 1) % 2][j]\n\n        return dp[m % 2][n]\n```\n\n6. Using a defaultdict for memoization:\n\n```python\nfrom collections import defaultdict\n\nclass Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        Given two strings s and t, return the number of distinct subsequences of s which equals t.\n        The test cases are generated so that the answer fits on a 32-bit signed integer.\n        ...\n        \"\"\"\n        memo = defaultdict(int)\n        \n        def dp(i, j):\n            if j == len(t):\n                return 1\n            if i == len(s):\n                return 0\n            if (i, j) in memo:\n                return memo[(i, j)]\n            \n            if s[i] == t[j]:\n                memo[(i, j)] = dp(i + 1, j + 1) + dp(i + 1, j)\n            else:\n                memo[(i, j)] = dp(i + 1, j)\n            \n            return memo[(i, j)]\n        \n        return dp(0, 0)\n```\n\n7. Using a 2D list with optimized space:\n\n```python\nclass Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        Given two strings s and t, return the number of distinct subsequences of s which equals t.\n        The test cases are generated so that the answer fits on a 32-bit signed integer.\n        ...\n        \"\"\"\n        m, n = len(s), len(t)\n        dp = [0] * (n + 1)\n        dp[0] = 1\n\n        for i in range(1, m + 1):\n            prev = dp[0]\n            for j in range(1, n + 1):\n                temp = dp[j]\n                if s[i - 1] == t[j - 1]:\n                    dp[j] = prev + dp[j]\n                prev = temp\n\n        return dp[n]\n```\n\n8. Using a 2D list with optimized space (rolling array):\n\n```python\nclass Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        Given two strings s and t, return the number of distinct subsequences of s which equals t.\n        The test cases are generated so that the answer fits on a 32-bit signed integer.\n        ...\n        \"\"\"\n        m, n = len(s), len(t)\n        dp = [[0] * (n + 1) for _ in range(2)]\n        dp[0][0] = 1\n\n        for i in range(1, m + 1):\n            dp[i % 2][0]\n\n = 1\n            prev = dp[(i - 1) % 2][0]\n            for j in range(1, n + 1):\n                temp = dp[i % 2][j]\n                if s[i - 1] == t[j - 1]:\n                    dp[i % 2][j] = prev + dp[(i - 1) % 2][j]\n                prev = temp\n\n        return dp[m % 2][n]\n```\n\n9. Using a 2D list with optimized space (iterative):\n\n```python\nclass Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        Given two strings s and t, return the number of distinct subsequences of s which equals t.\n        The test cases are generated so that the answer fits on a 32-bit signed integer.\n        ...\n        \"\"\"\n        m, n = len(s), len(t)\n        dp = [[0] * (n + 1) for _ in range(2)]\n        dp[0][0] = 1\n\n        for i in range(m + 1):\n            for j in range(n + 1):\n                if j > 0:\n                    dp[i % 2][j] = dp[(i - 1) % 2][j]\n                    if s[i - 1] == t[j - 1]:\n                        dp[i % 2][j] += dp[(i - 1) % 2][j - 1]\n\n        return dp[m % 2][n]\n```\n\n10. Using a 2D list with optimized space (iterative, reversed loops):\n\n```python\nclass Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        Given two strings s and t, return the number of distinct subsequences of s which equals t.\n        The test cases are generated so that the answer fits on a 32-bit signed integer.\n        ...\n        \"\"\"\n        m, n = len(s), len(t)\n        dp = [[0] * (n + 1) for _ in range(2)]\n        dp[0][0] = 1\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                dp[i % 2][j] = dp[(i - 1) % 2][j]\n                if s[i - 1] == t[j - 1]:\n                    dp[i % 2][j] += dp[(i - 1) % 2][j - 1]\n\n        return dp[m % 2][n]\n```\n\nThese code snippets provide different ways to solve the problem of finding the number of distinct subsequences of `s` that equal `t`.",
    "JavaScript": "Here are 10 different JavaScript code snippets to solve the problem of finding the number of distinct subsequences of string `s` that equals string `t`:\n\n1. Using Dynamic Programming (Bottom-Up Approach):\n```javascript\nvar numDistinct = function(s, t) {\n    const m = s.length;\n    const n = t.length;\n    \n    const dp = Array(m + 1).fill(0).map(() => Array(n + 1).fill(0));\n    \n    for (let i = 0; i <= m; i++) {\n        dp[i][0] = 1;\n    }\n    \n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            if (s[i - 1] === t[j - 1]) {\n                dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j];\n            } else {\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n    \n    return dp[m][n];\n};\n```\n\n2. Using Memoization (Top-Down Approach):\n```javascript\nvar numDistinct = function(s, t) {\n    const m = s.length;\n    const n = t.length;\n    \n    const memo = {};\n    \n    function dfs(i, j) {\n        if (j === n) return 1;\n        if (i === m) return 0;\n        \n        const key = i + '-' + j;\n        if (memo[key] !== undefined) return memo[key];\n        \n        let ways = 0;\n        if (s[i] === t[j]) {\n            ways += dfs(i + 1, j + 1);\n        }\n        ways += dfs(i + 1, j);\n        \n        memo[key] = ways;\n        return ways;\n    }\n    \n    return dfs(0, 0);\n};\n```\n\n3. Using a 1D Array (Optimized DP):\n```javascript\nvar numDistinct = function(s, t) {\n    const m = s.length;\n    const n = t.length;\n    \n    const dp = Array(n + 1).fill(0);\n    dp[0] = 1;\n    \n    for (let i = 1; i <= m; i++) {\n        for (let j = n; j >= 1; j--) {\n            if (s[i - 1] === t[j - 1]) {\n                dp[j] += dp[j - 1];\n            }\n        }\n    }\n    \n    return dp[n];\n};\n```\n\n4. Using Recursion (Brute Force):\n```javascript\nvar numDistinct = function(s, t) {\n    function dfs(i, j) {\n        if (j === t.length) return 1;\n        if (i === s.length) return 0;\n        \n        let ways = 0;\n        if (s[i] === t[j]) {\n            ways += dfs(i + 1, j + 1);\n        }\n        ways += dfs(i + 1, j);\n        \n        return ways;\n    }\n    \n    return dfs(0, 0);\n};\n```\n\n5. Using Iterative Approach with 2D Array:\n```javascript\nvar numDistinct = function(s, t) {\n    const m = s.length;\n    const n = t.length;\n    \n    const dp = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0));\n    \n    for (let i = 0; i <= m; i++) {\n        dp[i][0] = 1;\n    }\n    \n    for (let i = 1; i <= m; i++) {\n        for (let j = 1; j <= n; j++) {\n            dp[i][j] = dp[i - 1][j] + (s[i - 1] === t[j - 1] ? dp[i - 1][j - 1] : 0);\n        }\n    }\n    \n    return dp[m][n];\n};\n```\n\n6. Using Iterative Approach with 1D Array:\n```javascript\nvar numDistinct = function(s, t) {\n    const m = s.length;\n    const n = t.length;\n    \n    const dp = new Array(n + 1).fill(0);\n    dp[0] = 1;\n    \n    for (let i = 1; i <= m; i++) {\n        for (let j = n; j >= 1; j--) {\n            dp[j] += s[i - 1] === t[j - 1] ? dp[j - 1] : 0;\n        }\n    }\n    \n    return dp[n];\n};\n```\n\n7. Using Recursion with Memoization:\n```javascript\nvar numDistinct = function(s, t) {\n    const memo = new Map();\n    \n    function dfs(i, j) {\n        if (j === t.length) return 1;\n        if (i === s.length) return 0;\n        \n        const key = i + '-' + j;\n        if (memo.has(key)) return memo.get(key);\n        \n        let ways = 0;\n        if (s[i] === t[j]) {\n            ways += dfs(i + 1, j + 1);\n        }\n        ways += dfs(i + 1, j);\n        \n        memo.set(key, ways);\n        return ways;\n    }\n    \n    return dfs(0, 0);\n};\n```\n\n8. Using a 2D Array with Optimized Space:\n```javascript\nvar numDistinct = function(s, t) {\n    const m = s.length;\n    const n = t.length;\n    \n    const dp = Array(n + 1).fill(0);\n    dp[0] = 1;\n    \n    for (let i = 1; i <= m; i++) {\n        for (let j = n; j >= 1; j--) {\n            dp[j] += s[i - 1] === t[j - 1] ? dp[j - 1] : 0;\n        }\n    }\n    \n    return dp[n];\n};\n```\n\n9. Using a 2D Array with Space Optimization (No Need for dp[0] Initialization):\n```javascript\nvar numDistinct = function(s, t) {\n    const m = s.length;\n    const n = t.length;\n    \n    const dp = Array(n + 1).fill(0);\n    dp[0] = 1;\n    \n    for (let i = 1; i <= m; i++) {\n        for (let j = n; j >= 1; j--) {\n            dp[j] += s[i - 1] === t[j - 1] ? dp[j - 1] : 0;\n        }\n    }\n    \n    return dp[n];\n};\n```\n\n10. Using a 2D Array with Space Optimization (No Need for dp[0] Initialization and Only One Loop):\n```javascript\nvar numDistinct = function(s, t) {\n    const m = s.length;\n    const n = t.length;\n    \n    const dp = Array(n + 1).fill(0);\n    dp[0] = 1;\n    \n    for (let i = 1; i <=\n\n m; i++) {\n        for (let j = n; j >= 1; j--) {\n            dp[j] += s[i - 1] === t[j - 1] ? dp[j - 1] : 0;\n        }\n    }\n    \n    return dp[n];\n};\n```\n\nYou can choose any of these code snippets based on your preference or specific requirements. They all solve the problem of finding the number of distinct subsequences of `s` that equal `t`."
}