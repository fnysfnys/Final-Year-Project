{
    "Java": "Here are 10 different Java code snippets to implement the `nthUglyNumber` method based on the provided docstring:\n\n1. Using a while loop and checking each number:\n\n```java\npublic int nthUglyNumber(int n) {\n    if (n <= 0) return 0;\n    int count = 1;\n    int num = 1;\n    while (count < n) {\n        num++;\n        if (isUgly(num)) {\n            count++;\n        }\n    }\n    return num;\n}\n\nprivate boolean isUgly(int num) {\n    while (num % 2 == 0) {\n        num /= 2;\n    }\n    while (num % 3 == 0) {\n        num /= 3;\n    }\n    while (num % 5 == 0) {\n        num /= 5;\n    }\n    return num == 1;\n}\n```\n\n2. Using a dynamic programming approach:\n\n```java\npublic int nthUglyNumber(int n) {\n    int[] ugly = new int[n];\n    ugly[0] = 1;\n    int index2 = 0, index3 = 0, index5 = 0;\n    int factor2 = 2, factor3 = 3, factor5 = 5;\n\n    for (int i = 1; i < n; i++) {\n        int min = Math.min(Math.min(factor2, factor3), factor5);\n        ugly[i] = min;\n\n        if (factor2 == min) {\n            index2++;\n            factor2 = 2 * ugly[index2];\n        }\n        if (factor3 == min) {\n            index3++;\n            factor3 = 3 * ugly[index3];\n        }\n        if (factor5 == min) {\n            index5++;\n            factor5 = 5 * ugly[index5];\n        }\n    }\n\n    return ugly[n - 1];\n}\n```\n\n3. Using a PriorityQueue (Min Heap):\n\n```java\nimport java.util.PriorityQueue;\n\npublic int nthUglyNumber(int n) {\n    if (n == 1) return 1;\n\n    PriorityQueue<Long> minHeap = new PriorityQueue<>();\n    minHeap.offer(1L);\n    long ugly = 1;\n\n    for (int i = 1; i < n; i++) {\n        ugly = minHeap.poll();\n        while (!minHeap.isEmpty() && minHeap.peek() == ugly) {\n            minHeap.poll(); // Remove duplicates\n        }\n        minHeap.offer(ugly * 2);\n        minHeap.offer(ugly * 3);\n        minHeap.offer(ugly * 5);\n    }\n\n    return (int) ugly;\n}\n```\n\n4. Using an array to store the ugly numbers:\n\n```java\npublic int nthUglyNumber(int n) {\n    int[] ugly = new int[n];\n    ugly[0] = 1;\n    int index2 = 0, index3 = 0, index5 = 0;\n    int factor2 = 2, factor3 = 3, factor5 = 5;\n\n    for (int i = 1; i < n; i++) {\n        ugly[i] = Math.min(Math.min(factor2, factor3), factor5);\n\n        if (ugly[i] == factor2) {\n            index2++;\n            factor2 = 2 * ugly[index2];\n        }\n        if (ugly[i] == factor3) {\n            index3++;\n            factor3 = 3 * ugly[index3];\n        }\n        if (ugly[i] == factor5) {\n            index5++;\n            factor5 = 5 * ugly[index5];\n        }\n    }\n\n    return ugly[n - 1];\n}\n```\n\n5. Using recursion:\n\n```java\npublic int nthUglyNumber(int n) {\n    if (n <= 0) return 0;\n    if (n == 1) return 1;\n\n    int next = 1;\n    int num = 2;\n    while (next < n) {\n        if (isUgly(num)) {\n            next++;\n        }\n        if (next < n) {\n            num++;\n        }\n    }\n    return num;\n}\n\nprivate boolean isUgly(int num) {\n    if (num <= 0) return false;\n    while (num % 2 == 0) num /= 2;\n    while (num % 3 == 0) num /= 3;\n    while (num % 5 == 0) num /= 5;\n    return num == 1;\n}\n```\n\n6. Using a Set to store ugly numbers and avoid duplicates:\n\n```java\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic int nthUglyNumber(int n) {\n    Set<Integer> uglySet = new HashSet<>();\n    uglySet.add(1);\n    int ugly = 1;\n\n    while (n > 0) {\n        ugly = uglySet.stream().min(Integer::compareTo).get();\n        uglySet.remove(ugly);\n\n        uglySet.add(ugly * 2);\n        uglySet.add(ugly * 3);\n        uglySet.add(ugly * 5);\n\n        n--;\n    }\n\n    return ugly;\n}\n```\n\n7. Using a List to store ugly numbers:\n\n```java\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Collections;\n\npublic int nthUglyNumber(int n) {\n    if (n <= 0) return 0;\n    if (n == 1) return 1;\n\n    List<Integer> uglyNumbers = new ArrayList<>();\n    uglyNumbers.add(1);\n    int index2 = 0, index3 = 0, index5 = 0;\n\n    while (uglyNumbers.size() < n) {\n        int nextUgly = Math.min(uglyNumbers.get(index2) * 2, Math.min(uglyNumbers.get(index3) * 3, uglyNumbers.get(index5) * 5));\n        uglyNumbers.add(nextUgly);\n\n        if (nextUgly == uglyNumbers.get(index2) * 2) index2++;\n        if (nextUgly == uglyNumbers.get(index3) * 3) index3++;\n        if (nextUgly == uglyNumbers.get(index5) * 5) index5++;\n    }\n\n    return uglyNumbers.get(n - 1);\n}\n```\n\n8. Using a TreeSet to store ugly numbers:\n\n```java\nimport java.util.TreeSet;\n\npublic int nthUglyNumber(int n) {\n    TreeSet<Integer> uglySet = new TreeSet<>();\n    uglySet.add(1);\n\n    while (n > 1) {\n        int smallest = uglySet.pollFirst();\n        uglySet.add(smallest * 2);\n        uglySet.add(smallest * 3);\n        uglySet.add(smallest * 5);\n        n--;\n    }\n\n    return uglySet.first();\n}\n```\n\n9. Using a HashSet and sorting:\n\n```java\nimport java.util.HashSet;\nimport java.util.PriorityQueue;\n\npublic int nthUglyNumber(int n) {\n    HashSet<Long> seen = new HashSet<>();\n    PriorityQueue<Long> pq = new PriorityQueue<>();\n    pq.offer(1L);\n    seen.add(1L);\n\n    int[] primes = {2, 3, 5};\n    long ugly = 1;\n\n    for (int i = 0; i < n; i++) {\n        ugly = pq\n\n.poll();\n        for (int prime : primes) {\n            long nextUgly = ugly * prime;\n            if (!seen.contains(nextUgly)) {\n                seen.add(nextUgly);\n                pq.offer(nextUgly);\n            }\n        }\n    }\n\n    return (int) ugly;\n}\n```\n\n10. Using an array of factors and indexes:\n\n```java\npublic int nthUglyNumber(int n) {\n    int[] ugly = new int[n];\n    ugly[0] = 1;\n    int[] factors = {2, 3, 5};\n    int[] indexes = {0, 0, 0};\n\n    for (int i = 1; i < n; i++) {\n        int min = Integer.MAX_VALUE;\n        for (int j = 0; j < factors.length; j++) {\n            min = Math.min(min, ugly[indexes[j]] * factors[j]);\n        }\n        ugly[i] = min;\n\n        for (int j = 0; j < factors.length; j++) {\n            if (min == ugly[indexes[j]] * factors[j]) {\n                indexes[j]++;\n            }\n        }\n    }\n\n    return ugly[n - 1];\n}\n```\n\nYou can choose any of these implementations to solve the problem of finding the nth ugly number.",
    "Python": "Here are 10 different Python code snippets based on the provided docstring for the `nthUglyNumber` function:\n\n1. Basic Solution using a while loop:\n```python\nclass Solution(object):\n    def nthUglyNumber(self, n):\n        \"\"\"\n        An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\n        Given an integer n, return the nth ugly number.\n        \"\"\"\n        ugly_numbers = [1]\n        i, j, k = 0, 0, 0\n\n        while len(ugly_numbers) < n:\n            next_ugly = min(ugly_numbers[i] * 2, ugly_numbers[j] * 3, ugly_numbers[k] * 5)\n            ugly_numbers.append(next_ugly)\n\n            if next_ugly == ugly_numbers[i] * 2:\n                i += 1\n            if next_ugly == ugly_numbers[j] * 3:\n                j += 1\n            if next_ugly == ugly_numbers[k] * 5:\n                k += 1\n\n        return ugly_numbers[-1]\n```\n\n2. Using a set to avoid duplicates:\n```python\nclass Solution(object):\n    def nthUglyNumber(self, n):\n        \"\"\"\n        An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\n        Given an integer n, return the nth ugly number.\n        \"\"\"\n        ugly_numbers = {1}\n        heap = [1]\n\n        while n > 0:\n            current = heapq.heappop(heap)\n            n -= 1\n\n            for factor in [2, 3, 5]:\n                next_ugly = current * factor\n                if next_ugly not in ugly_numbers:\n                    ugly_numbers.add(next_ugly)\n                    heapq.heappush(heap, next_ugly)\n\n        return current\n```\n\n3. Using dynamic programming:\n```python\nclass Solution(object):\n    def nthUglyNumber(self, n):\n        \"\"\"\n        An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\n        Given an integer n, return the nth ugly number.\n        \"\"\"\n        ugly_numbers = [1]\n        i, j, k = 0, 0, 0\n\n        while len(ugly_numbers) < n:\n            next_ugly = min(ugly_numbers[i] * 2, ugly_numbers[j] * 3, ugly_numbers[k] * 5)\n            ugly_numbers.append(next_ugly)\n\n            if next_ugly == ugly_numbers[i] * 2:\n                i += 1\n            if next_ugly == ugly_numbers[j] * 3:\n                j += 1\n            if next_ugly == ugly_numbers[k] * 5:\n                k += 1\n\n        return ugly_numbers[-1]\n```\n\n4. Using a generator function:\n```python\nclass Solution(object):\n    def nthUglyNumber(self, n):\n        \"\"\"\n        An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\n        Given an integer n, return the nth ugly number.\n        \"\"\"\n        def generate_ugly_numbers():\n            ugly_numbers = [1]\n            i, j, k = 0, 0, 0\n\n            while True:\n                next_ugly = min(ugly_numbers[i] * 2, ugly_numbers[j] * 3, ugly_numbers[k] * 5)\n                yield next_ugly\n\n                if next_ugly == ugly_numbers[i] * 2:\n                    i += 1\n                if next_ugly == ugly_numbers[j] * 3:\n                    j += 1\n                if next_ugly == ugly_numbers[k] * 5:\n                    k += 1\n\n        gen = generate_ugly_numbers()\n        for _ in range(n - 1):\n            next(gen)\n\n        return next(gen)\n```\n\n5. Using memoization:\n```python\nclass Solution(object):\n    def nthUglyNumber(self, n):\n        \"\"\"\n        An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\n        Given an integer n, return the nth ugly number.\n        \"\"\"\n        ugly_numbers = [1]\n        i, j, k = 0, 0, 0\n\n        while len(ugly_numbers) < n:\n            next_ugly = min(ugly_numbers[i] * 2, ugly_numbers[j] * 3, ugly_numbers[k] * 5)\n            ugly_numbers.append(next_ugly)\n\n            if next_ugly == ugly_numbers[i] * 2:\n                i += 1\n            if next_ugly == ugly_numbers[j] * 3:\n                j += 1\n            if next_ugly == ugly_numbers[k] * 5:\n                k += 1\n\n        return ugly_numbers[-1]\n```\n\n6. Using a brute-force approach:\n```python\nclass Solution(object):\n    def nthUglyNumber(self, n):\n        \"\"\"\n        An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\n        Given an integer n, return the nth ugly number.\n        \"\"\"\n        ugly_numbers = [1]\n        i = 2\n\n        while len(ugly_numbers) < n:\n            if i % 2 == 0 or i % 3 == 0 or i % 5 == 0:\n                ugly_numbers.append(i)\n            i += 1\n\n        return ugly_numbers[-1]\n```\n\n7. Using a more efficient heap-based approach:\n```python\nimport heapq\n\nclass Solution(object):\n    def nthUglyNumber(self, n):\n        \"\"\"\n        An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\n        Given an integer n, return the nth ugly number.\n        \"\"\"\n        ugly_numbers = [1]\n        heap = [(2, 2), (3, 3), (5, 5)]\n\n        while len(ugly_numbers) < n:\n            next_ugly, factor = heapq.heappop(heap)\n            ugly_numbers.append(next_ugly)\n\n            if factor == 2:\n                heapq.heappush(heap, (next_ugly * 2, 2))\n            elif factor == 3:\n                heapq.heappush(heap, (next_ugly * 3, 3))\n            else:\n                heapq.heappush(heap, (next_ugly * 5, 5))\n\n        return ugly_numbers[-1]\n```\n\n8. Using a list comprehension:\n```python\nclass Solution(object):\n    def nthUglyNumber(self, n):\n        \"\"\"\n        An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\n        Given an integer n, return the nth ugly number.\n        \"\"\"\n        ugly_numbers = [1]\n        i, j, k = 0, 0, 0\n\n        while len(ugly_numbers) < n:\n            next_ugly = min(ugly_numbers[i] * 2, ugly_numbers[j] * 3, ugly_numbers[k] * 5\n\n)\n            ugly_numbers.append(next_ugly)\n\n            i += 1 if next_ugly == ugly_numbers[i] * 2 else 0\n            j += 1 if next_ugly == ugly_numbers[j] * 3 else 0\n            k += 1 if next_ugly == ugly_numbers[k] * 5 else 0\n\n        return ugly_numbers[-1]\n```\n\n9. Using a simple loop:\n```python\nclass Solution(object):\n    def nthUglyNumber(self, n):\n        \"\"\"\n        An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\n        Given an integer n, return the nth ugly number.\n        \"\"\"\n        ugly_numbers = [1]\n        i, j, k = 0, 0, 0\n\n        for _ in range(n - 1):\n            next_ugly = min(ugly_numbers[i] * 2, ugly_numbers[j] * 3, ugly_numbers[k] * 5)\n            ugly_numbers.append(next_ugly)\n\n            if next_ugly == ugly_numbers[i] * 2:\n                i += 1\n            if next_ugly == ugly_numbers[j] * 3:\n                j += 1\n            if next_ugly == ugly_numbers[k] * 5:\n                k += 1\n\n        return ugly_numbers[-1]\n```\n\n10. Using a deque for efficient popping:\n```python\nfrom collections import deque\n\nclass Solution(object):\n    def nthUglyNumber(self, n):\n        \"\"\"\n        An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\n        Given an integer n, return the nth ugly number.\n        \"\"\"\n        ugly_numbers = [1]\n        i, j, k = 0, 0, 0\n        queue2, queue3, queue5 = deque([2]), deque([3]), deque([5])\n\n        while len(ugly_numbers) < n:\n            next_ugly = min(queue2[0], queue3[0], queue5[0])\n            ugly_numbers.append(next_ugly)\n\n            if next_ugly == queue2[0]:\n                queue2.popleft()\n            if next_ugly == queue3[0]:\n                queue3.popleft()\n            if next_ugly == queue5[0]:\n                queue5.popleft()\n\n            queue2.append(next_ugly * 2)\n            queue3.append(next_ugly * 3)\n            queue5.append(next_ugly * 5)\n\n        return ugly_numbers[-1]\n```",
    "JavaScript": "Here are 10 different JavaScript code snippets to solve the problem of finding the nth ugly number based on the provided docstring:\n\n1. Using a while loop and a set to keep track of ugly numbers:\n```javascript\n/**\n * @param {number} n\n * @return {number}\n */\nvar nthUglyNumber = function(n) {\n    const uglyNumbers = new Set([1]);\n    let num = 2;\n\n    while (uglyNumbers.size < n) {\n        if (isUgly(num)) {\n            uglyNumbers.add(num);\n        }\n        num++;\n    }\n\n    return Array.from(uglyNumbers).pop();\n};\n\nfunction isUgly(num) {\n    while (num % 2 === 0) {\n        num /= 2;\n    }\n    while (num % 3 === 0) {\n        num /= 3;\n    }\n    while (num % 5 === 0) {\n        num /= 5;\n    }\n    return num === 1;\n}\n```\n\n2. Using dynamic programming to generate ugly numbers:\n```javascript\n/**\n * @param {number} n\n * @return {number}\n */\nvar nthUglyNumber = function(n) {\n    const uglyNumbers = [1];\n    let i2 = 0, i3 = 0, i5 = 0;\n\n    while (uglyNumbers.length < n) {\n        const nextUgly = Math.min(uglyNumbers[i2] * 2, uglyNumbers[i3] * 3, uglyNumbers[i5] * 5);\n        uglyNumbers.push(nextUgly);\n\n        if (nextUgly === uglyNumbers[i2] * 2) i2++;\n        if (nextUgly === uglyNumbers[i3] * 3) i3++;\n        if (nextUgly === uglyNumbers[i5] * 5) i5++;\n    }\n\n    return uglyNumbers[n - 1];\n};\n```\n\n3. Using a priority queue (min-heap) to efficiently find the next ugly number:\n```javascript\n/**\n * @param {number} n\n * @return {number}\n */\nvar nthUglyNumber = function(n) {\n    const heap = [1];\n    const factors = [2, 3, 5];\n\n    while (n > 1) {\n        const curr = heap.shift();\n        for (const factor of factors) {\n            const next = curr * factor;\n            if (!heap.includes(next)) {\n                heap.push(next);\n            }\n        }\n        heap.sort((a, b) => a - b);\n        n--;\n    }\n\n    return heap[0];\n};\n```\n\n4. Using a memoization table to avoid recomputation:\n```javascript\n/**\n * @param {number} n\n * @return {number}\n */\nvar nthUglyNumber = function(n) {\n    const uglyNumbers = [1];\n    let p2 = 0, p3 = 0, p5 = 0;\n\n    while (uglyNumbers.length < n) {\n        const nextUgly = Math.min(uglyNumbers[p2] * 2, uglyNumbers[p3] * 3, uglyNumbers[p5] * 5);\n        uglyNumbers.push(nextUgly);\n\n        if (nextUgly === uglyNumbers[p2] * 2) p2++;\n        if (nextUgly === uglyNumbers[p3] * 3) p3++;\n        if (nextUgly === uglyNumbers[p5] * 5) p5++;\n    }\n\n    return uglyNumbers[n - 1];\n};\n```\n\n5. Using a more efficient approach without duplicates in a while loop:\n```javascript\n/**\n * @param {number} n\n * @return {number}\n */\nvar nthUglyNumber = function(n) {\n    const uglyNumbers = [1];\n    let i2 = 0, i3 = 0, i5 = 0;\n\n    while (uglyNumbers.length < n) {\n        const nextUgly = Math.min(uglyNumbers[i2] * 2, uglyNumbers[i3] * 3, uglyNumbers[i5] * 5);\n        uglyNumbers.push(nextUgly);\n\n        if (nextUgly === uglyNumbers[i2] * 2) i2++;\n        if (nextUgly === uglyNumbers[i3] * 3) i3++;\n        if (nextUgly === uglyNumbers[i5] * 5) i5++;\n    }\n\n    return uglyNumbers.pop();\n};\n```\n\n6. Using a memoization table with a more concise approach:\n```javascript\n/**\n * @param {number} n\n * @return {number}\n */\nvar nthUglyNumber = function(n) {\n    const uglyNumbers = [1];\n    let p2 = 0, p3 = 0, p5 = 0;\n\n    while (uglyNumbers.length < n) {\n        const nextUgly = Math.min(uglyNumbers[p2] * 2, uglyNumbers[p3] * 3, uglyNumbers[p5] * 5);\n        uglyNumbers.push(nextUgly);\n\n        if (nextUgly === uglyNumbers[p2] * 2) p2++;\n        if (nextUgly === uglyNumbers[p3] * 3) p3++;\n        if (nextUgly === uglyNumbers[p5] * 5) p5++;\n    }\n\n    return uglyNumbers.pop();\n};\n```\n\n7. Using a for loop and an array to track ugly numbers:\n```javascript\n/**\n * @param {number} n\n * @return {number}\n */\nvar nthUglyNumber = function(n) {\n    const uglyNumbers = [1];\n    let i2 = 0, i3 = 0, i5 = 0;\n\n    for (let i = 1; i < n; i++) {\n        const nextUgly = Math.min(uglyNumbers[i2] * 2, uglyNumbers[i3] * 3, uglyNumbers[i5] * 5);\n        uglyNumbers.push(nextUgly);\n\n        if (nextUgly === uglyNumbers[i2] * 2) i2++;\n        if (nextUgly === uglyNumbers[i3] * 3) i3++;\n        if (nextUgly === uglyNumbers[i5] * 5) i5++;\n    }\n\n    return uglyNumbers[n - 1];\n};\n```\n\n8. Using a for loop with a while loop for finding the next ugly number:\n```javascript\n/**\n * @param {number} n\n * @return {number}\n */\nvar nthUglyNumber = function(n) {\n    const uglyNumbers = [1];\n    let i2 = 0, i3 = 0, i5 = 0;\n\n    for (let i = 1; i < n; i++) {\n        let nextUgly = uglyNumbers[i2] * 2;\n        while (nextUgly <= uglyNumbers[i - 1]) {\n            i2++;\n            nextUgly = uglyNumbers[i2] * 2;\n        }\n\n        nextUgly = uglyNumbers[i3] * 3;\n        while (nextUgly <= uglyNumbers[i - 1]) {\n            i3++;\n            nextUgly = uglyNumbers[i3] * 3;\n        }\n\n        nextUgly = uglyNumbers[i5]\n\n * 5;\n        while (nextUgly <= uglyNumbers[i - 1]) {\n            i5++;\n            nextUgly = uglyNumbers[i5] * 5;\n        }\n\n        uglyNumbers.push(Math.min(uglyNumbers[i2] * 2, uglyNumbers[i3] * 3, uglyNumbers[i5] * 5));\n    }\n\n    return uglyNumbers[n - 1];\n};\n```\n\n9. Using a generator function to find the nth ugly number:\n```javascript\n/**\n * @param {number} n\n * @return {number}\n */\nvar nthUglyNumber = function(n) {\n    function* generateUglyNumbers() {\n        const uglyNumbers = [1];\n        let i2 = 0, i3 = 0, i5 = 0;\n\n        while (true) {\n            const nextUgly = Math.min(uglyNumbers[i2] * 2, uglyNumbers[i3] * 3, uglyNumbers[i5] * 5);\n            uglyNumbers.push(nextUgly);\n\n            if (nextUgly === uglyNumbers[i2] * 2) i2++;\n            if (nextUgly === uglyNumbers[i3] * 3) i3++;\n            if (nextUgly === uglyNumbers[i5] * 5) i5++;\n\n            yield uglyNumbers[uglyNumbers.length - 1];\n        }\n    }\n\n    const generator = generateUglyNumbers();\n    for (let i = 1; i < n; i++) {\n        generator.next();\n    }\n\n    return generator.next().value;\n};\n```\n\n10. Using a recursive approach with memoization:\n```javascript\n/**\n * @param {number} n\n * @return {number}\n */\nvar nthUglyNumber = function(n) {\n    const memo = new Map();\n\n    function findNthUglyNumber(index) {\n        if (index === 1) return 1;\n        if (memo.has(index)) return memo.get(index);\n\n        const nextUgly = Math.min(\n            findNthUglyNumber(index - 1) * 2,\n            findNthUglyNumber(index - 1) * 3,\n            findNthUglyNumber(index - 1) * 5\n        );\n\n        memo.set(index, nextUgly);\n        return nextUgly;\n    }\n\n    return findNthUglyNumber(n);\n};\n```\n\nThese are 10 different JavaScript code snippets to find the nth ugly number based on the provided docstring, each using a different approach. You can choose the one that suits your needs or preferences."
}