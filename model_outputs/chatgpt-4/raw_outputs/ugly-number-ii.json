{
    "JavaScript": "Sure, I'll provide 10 different JavaScript code snippets for the function `nthUglyNumber` based on the provided docstring. Each snippet will aim to solve the problem in a slightly different way.\n\n### Snippet 1: Basic Dynamic Programming Approach\n\n```javascript\n/**\n * An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\n * Given an integer n, return the nth ugly number.\n */\nvar nthUglyNumber = function(n) {\n    let uglyNumbers = [1];\n    let i2 = 0, i3 = 0, i5 = 0;\n\n    while (uglyNumbers.length < n) {\n        let next2 = uglyNumbers[i2] * 2;\n        let next3 = uglyNumbers[i3] * 3;\n        let next5 = uglyNumbers[i5] * 5;\n        let nextUgly = Math.min(next2, next3, next5);\n        if (nextUgly === next2) i2++;\n        if (nextUgly === next3) i3++;\n        if (nextUgly === next5) i5++;\n        uglyNumbers.push(nextUgly);\n    }\n\n    return uglyNumbers[n - 1];\n};\n```\n\n### Snippet 2: Recursive Memoization Approach\n\n```javascript\n/**\n * An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\n * Given an integer n, return the nth ugly number.\n */\nvar nthUglyNumber = function(n, memo = {1: 1}) {\n    if (memo[n] !== undefined) return memo[n];\n\n    let count = 1, num = 1;\n    while (count < n) {\n        num++;\n        if (isUgly(num)) {\n            memo[++count] = num;\n        }\n    }\n\n    return memo[n];\n\n    function isUgly(num) {\n        for (let p of [2, 3, 5]) {\n            while (num % p === 0) num /= p;\n        }\n        return num === 1;\n    }\n};\n```\n\n### Snippet 3: Iterative Approach with Set\n\n```javascript\n/**\n * An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\n * Given an integer n, return the nth ugly number.\n */\nvar nthUglyNumber = function(n) {\n    let seen = new Set([1]);\n    let heap = [1];\n\n    while (seen.size < n) {\n        let current = heap.shift();\n        for (let factor of [2, 3, 5]) {\n            let next = current * factor;\n            if (!seen.has(next)) {\n                seen.add(next);\n                heap.push(next);\n                heap.sort((a, b) => a - b);\n            }\n        }\n    }\n\n    return heap[0];\n};\n```\n\n### Snippet 4: Priority Queue Optimization\n\n```javascript\n/**\n * An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\n * Given an integer n, return the nth ugly number.\n */\nclass PriorityQueue {\n    constructor(comparator = (a, b) => a - b) {\n        this._heap = [];\n        this._comparator = comparator;\n    }\n\n    push(value) {\n        this._heap.push(value);\n        this._heap.sort(this._comparator);\n    }\n\n    pop() {\n        return this._heap.shift();\n    }\n\n    size() {\n        return this._heap.length;\n    }\n}\n\nvar nthUglyNumber = function(n) {\n    let pq = new PriorityQueue();\n    let seen = new Set([1]);\n    pq.push(1);\n\n    while (seen.size < n) {\n        let current = pq.pop();\n        for (let factor of [\n\n2, 3, 5]) {\n            let next = current * factor;\n            if (!seen.has(next)) {\n                seen.add(next);\n                pq.push(next);\n            }\n        }\n    }\n\n    return Array.from(seen).sort((a, b) => a - b)[n - 1];\n};\n```\n\n### Snippet 5: Using a Min-Heap for Optimization\n\n```javascript\n/**\n * An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\n * Given an integer n, return the nth ugly number.\n */\nclass MinHeap {\n    constructor() {\n        this.heap = [];\n    }\n\n    insert(num) {\n        this.heap.push(num);\n        this.heap.sort((a, b) => a - b);\n    }\n\n    remove() {\n        return this.heap.shift();\n    }\n\n    get size() {\n        return this.heap.length;\n    }\n}\n\nvar nthUglyNumber = function(n) {\n    let minHeap = new MinHeap();\n    minHeap.insert(1);\n    let value = 0;\n\n    for (let i = 0; i < n; i++) {\n        value = minHeap.remove();\n        [2, 3, 5].forEach(factor => {\n            if (!minHeap.heap.includes(value * factor)) {\n                minHeap.insert(value * factor);\n            }\n        });\n    }\n\n    return value;\n};\n```\n\n### Snippet 6: Leveraging JavaScript Sets for Uniqueness\n\n```javascript\n/**\n * An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\n * Given an integer n, return the nth ugly number.\n */\nvar nthUglyNumber = function(n) {\n    let uglyNumbers = new Set([1]);\n    let arr = [1];\n\n    while (arr.length < n) {\n        let min = Math.min(arr[0] * 2, arr[0] * 3, arr[0] * 5);\n        uglyNumbers.add(min);\n        arr.push(min);\n        arr = Array.from(uglyNumbers).sort((a, b) => a - b);\n        arr = arr.slice(arr.indexOf(min));\n    }\n\n    return arr[0];\n};\n```\n\n### Snippet 7: Simple Loop with Ugliness Check\n\n```javascript\n/**\n * An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\n * Given an integer n, return the nth ugly number.\n */\nvar nthUglyNumber = function(n) {\n    if (n === 1) return 1;\n\n    let count = 1;\n    for (let i = 2; count < n; i++) {\n        if (isUgly(i)) count++;\n        if (count === n) return i;\n    }\n\n    function isUgly(num) {\n        for (let p of [2, 3, 5]) {\n            while (num % p === 0) num /= p;\n        }\n        return num === 1;\n    }\n};\n```\n\n### Snippet 8: Dynamic Programming with Three Pointers (Optimized)\n\n```javascript\n/**\n * An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\n * Given an integer n, return the nth ugly number.\n */\nvar nthUglyNumber = function(n) {\n    let dp = Array(n).fill(0);\n    dp[0] = 1;\n    let p2 = 0, p3 = 0, p5 = 0;\n\n    for (let i = 1; i < n; i++) {\n        let next2 = dp\n\n[p2] * 2, next3 = dp[p3] * 3, next5 = dp[p5] * 5;\n        dp[i] = Math.min(next2, next3, next5);\n        if (dp[i] === next2) p2++;\n        if (dp[i] === next3) p3++;\n        if (dp[i] === next5) p5++;\n    }\n\n    return dp[n - 1];\n};\n```\n\n### Snippet 9: Using a Function to Calculate Next Ugly Number\n\n```javascript\n/**\n * An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\n * Given an integer n, return the nth ugly number.\n */\nvar nthUglyNumber = function(n) {\n    let nums = [1];\n    let i = 0, j = 0, k = 0;\n\n    while (nums.length < n) {\n        let next = Math.min(nums[i] * 2, nums[j] * 3, nums[k] * 5);\n        nums.push(next);\n        if (next === nums[i] * 2) i++;\n        if (next === nums[j] * 3) j++;\n        if (next === nums[k] * 5) k++;\n    }\n\n    return nums[n - 1];\n};\n```\n\n### Snippet 10: Iterative Approach with Array Sorting\n\n```javascript\n/**\n * An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\n * Given an integer n, return the nth ugly number.\n */\nvar nthUglyNumber = function(n) {\n    let uglies = [1];\n\n    for (let i = 1; i < n; i++) {\n        let last = uglies[i - 1];\n        let nextUglies = [last * 2, last * 3, last * 5].filter(x => !uglies.includes(x));\n        uglies.push(Math.min(...nextUglies));\n        uglies.sort((a, b) => a - b);\n    }\n\n    return uglies[n - 1];\n};\n```\n\nEach of these snippets provides a different method to solve the problem of finding the nth ugly number, varying from basic iterative approaches to more advanced techniques involving dynamic programming, memoization, priority queues, and more.",
    "Java": "Creating 10 different Java code snippets to complete the `nthUglyNumber` method in the `Solution` class is a substantial task. Each snippet will implement the method to return the nth ugly number, where an ugly number is defined as a positive integer whose prime factors are limited to 2, 3, and 5.\n\nHere are 10 distinct approaches to implement the `nthUglyNumber` method:\n\n### Snippet 1: Basic Dynamic Programming\n```java\npublic int nthUglyNumber(int n) {\n    int[] ugly = new int[n];\n    ugly[0] = 1;\n    int i2 = 0, i3 = 0, i5 = 0;\n    for (int i = 1; i < n; i++) {\n        ugly[i] = Math.min(Math.min(ugly[i2] * 2, ugly[i3] * 3), ugly[i5] * 5);\n        if (ugly[i] == ugly[i2] * 2) i2++;\n        if (ugly[i] == ugly[i3] * 3) i3++;\n        if (ugly[i] == ugly[i5] * 5) i5++;\n    }\n    return ugly[n - 1];\n}\n```\n\n### Snippet 2: Using Priority Queue\n```java\npublic int nthUglyNumber(int n) {\n    if (n == 1) return 1;\n    PriorityQueue<Long> pq = new PriorityQueue<>();\n    pq.add(1L);\n    for (int i = 1; i < n; i++) {\n        long temp = pq.poll();\n        while (!pq.isEmpty() && pq.peek() == temp) temp = pq.poll();\n\n        pq.add(temp * 2);\n        pq.add(temp * 3);\n        pq.add(temp * 5);\n    }\n    return pq.poll().intValue();\n}\n```\n\n### Snippet 3: Optimized Dynamic Programming\n```java\npublic int nthUglyNumber(int n) {\n    int[] ugly = new int[n];\n    ugly[0] = 1;\n    int factor2 = 2, factor3 = 3, factor5 = 5;\n    int index2 = 0, index3 = 0, index5 = 0;\n    for (int i = 1; i < n; i++) {\n        int min = Math.min(Math.min(factor2, factor3), factor5);\n        ugly[i] = min;\n        if (min == factor2) factor2 = 2 * ugly[++index2];\n        if (min == factor3) factor3 = 3 * ugly[++index3];\n        if (min == factor5) factor5 = 5 * ugly[++index5];\n    }\n    return ugly[n - 1];\n}\n```\n\n### Snippet 4: Using HashSet and PriorityQueue\n```java\npublic int nthUglyNumber(int n) {\n    if (n == 1) return 1;\n    PriorityQueue<Long> pq = new PriorityQueue<>();\n    HashSet<Long> set = new HashSet<>();\n    pq.add(1L);\n    set.add(1L);\n    long number = 1;\n    for (int i = 0; i < n; i++) {\n        number = pq.poll();\n        if (set.add(number * 2)) pq.add(number * 2);\n        if (set.add(number * 3)) pq.add(number * 3);\n        if (set.add(number * 5)) pq.add(number * 5);\n    }\n    return (int) number;\n}\n```\n\n### Snippet 5: Iterative Approach\n```java\npublic int nthUglyNumber(int n) {\n    if (n <= 0) return 0;\n    int count = 0, i = 1;\n    while (count < n) {\n        if (isUgly(i)) count++;\n        if (count < n) i++;\n    }\n    return i;\n}\n\nprivate boolean isUgly(int num) {\n    if (num <= 0) return false;\n    while (num % 2 == 0) num /= 2;\n    while (num % 3 == 0) num /= 3;\n    while (num % 5 == 0) num /= 5;\n    return num == 1;\n}\n```\n\n### Snippet 6: Using TreeSet for Unique Elements\n```java\npublic int nthUglyNumber(int n) {\n    if (n == 1) return 1;\n    TreeSet<Long> set = new TreeSet<>();\n    set.add(1L);\n    for (int i = 1; i < n; i++) {\n        long first = set.pollFirst();\n        set.add(first * 2);\n        set.add(first * 3);\n        set.add(first * 5);\n    }\n    return set.first().intValue();\n}\n```\n\n### Snippet 7\n\n: Dynamic Programming with Space Optimization\n```java\npublic int nthUglyNumber(int n) {\n    int[] ugly = new int[3];\n    ugly[0] = ugly[1] = ugly[2] = 1;\n    int nextUgly, next2 = 2, next3 = 3, next5 = 5;\n    int i2 = 0, i3 = 0, i5 = 0;\n    for (int i = 1; i < n; i++) {\n        nextUgly = Math.min(next2, Math.min(next3, next5));\n        if (nextUgly == next2) next2 = 2 * ugly[++i2];\n        if (nextUgly == next3) next3 = 3 * ugly[++i3];\n        if (nextUgly == next5) next5 = 5 * ugly[++i5];\n        ugly[i % 3] = nextUgly;\n    }\n    return ugly[(n - 1) % 3];\n}\n```\n\n### Snippet 8: Recursive Approach with Memoization\n```java\nint[] memo;\n\npublic int nthUglyNumber(int n) {\n    memo = new int[n + 1];\n    Arrays.fill(memo, -1);\n    return helper(n);\n}\n\nprivate int helper(int n) {\n    if (n <= 1) return 1;\n    if (memo[n] != -1) return memo[n];\n    int count = 1, num = 1;\n    while (count < n) {\n        num++;\n        if (isUgly(num)) count++;\n    }\n    memo[n] = num;\n    return num;\n}\n\nprivate boolean isUgly(int num) {\n    for (int i : new int[]{2, 3, 5}) {\n        while (num % i == 0) num /= i;\n    }\n    return num == 1;\n}\n```\n\n### Snippet 9: Using Binary Search\n```java\npublic int nthUglyNumber(int n) {\n    long left = 1, right = Integer.MAX_VALUE, mid;\n    while (left < right) {\n        mid = left + (right - left) / 2;\n        if (countUglyNumbers(mid) < n) left = mid + 1;\n        else right = mid;\n    }\n    return (int) left;\n}\n\nprivate long countUglyNumbers(long num) {\n    long count = 0;\n    for (long i = 1; i <= num; i++) {\n        if (isUgly(i)) count++;\n    }\n    return count;\n}\n\nprivate boolean isUgly(long num) {\n    for (int i : new int[]{2, 3, 5}) {\n        while (num % i == 0) num /= i;\n    }\n    return num == 1;\n}\n```\n\n### Snippet 10: Tabulation Method with Dynamic Programming\n```java\npublic int nthUglyNumber(int n) {\n    int[] dp = new int[n];\n    dp[0] = 1;\n    int idx2 = 0, idx3 = 0, idx5 = 0;\n    for (int i = 1; i < n; i++) {\n        dp[i] = Math.min(dp[idx2] * 2, Math.min(dp[idx3] * 3, dp[idx5] * 5));\n        if (dp[i] == dp[idx2] * 2) idx2++;\n        if (dp[i] == dp[idx3] * 3) idx3++;\n        if (dp[i] == dp[idx5] * 5) idx5++;\n    }\n    return dp[n - 1];\n}\n```\n\nEach of these snippets offers a different approach to solving the problem, using various techniques like dynamic programming, priority queues, hash sets, tree sets, recursion, and binary search.",
    "Python": "Sure, I will create 10 different Python code snippets, each providing a solution to find the nth ugly number. The definition of an ugly number is as provided in the docstring: a positive integer whose prime factors are limited to 2, 3, and 5. Each solution will offer a unique approach or optimization.\n\n### Snippet 1: Basic Dynamic Programming\n```python\nclass Solution(object):\n    def nthUglyNumber(self, n):\n        \"\"\"\n        (docstring as provided)\n        \"\"\"\n        ugly = [1]\n        i2 = i3 = i5 = 0\n        while len(ugly) < n:\n            u2, u3, u5 = 2 * ugly[i2], 3 * ugly[i3], 5 * ugly[i5]\n            umin = min(u2, u3, u5)\n            if umin == u2:\n                i2 += 1\n            if umin == u3:\n                i3 += 1\n            if umin == u5:\n                i5 += 1\n            ugly.append(umin)\n        return ugly[-1]\n```\n\n### Snippet 2: Using a Heap\n```python\nimport heapq\n\nclass Solution(object):\n    def nthUglyNumber(self, n):\n        \"\"\"\n        (docstring as provided)\n        \"\"\"\n        ugly_numbers = [1]\n        seen = {1}\n        factors = [2, 3, 5]\n\n        for _ in range(n - 1):\n            current = heapq.heappop(ugly_numbers)\n            for factor in factors:\n                new_ugly = current * factor\n                if new_ugly not in seen:\n                    seen.add(new_ugly)\n                    heapq.heappush(ugly_numbers, new_ugly)\n\n        return heapq.heappop(ugly_numbers)\n```\n\n### Snippet 3: Using a Set for Uniqueness Check\n```python\nclass Solution(object):\n    def nthUglyNumber(self, n):\n        \"\"\"\n        (docstring as provided)\n        \"\"\"\n        ugly = sorted(1 for _ in range(n))\n        seen = set(ugly)\n        factors = [2, 3, 5]\n\n        for i in range(1, n):\n            for factor in factors:\n                new_ugly = ugly[i - 1] * factor\n                if new_ugly not in seen:\n                    seen.add(new_ugly)\n                    ugly.append(new_ugly)\n            ugly.sort()\n\n        return ugly[n - 1]\n```\n\n### Snippet 4: Recursive Approach with Memoization\n```python\nclass Solution(object):\n    def nthUglyNumber(self, n):\n        \"\"\"\n        (docstring as provided)\n        \"\"\"\n        def helper(n, memo):\n            if n in memo:\n                return memo[n]\n            memo[n] = min(helper(n // 2, memo) * 2, helper(n // 3, memo) * 3, helper(n // 5, memo) * 5)\n            return memo[n]\n\n        memo = {1: 1}\n        return helper(n, memo)\n```\n\n### Snippet 5: Iterative Approach with Early Stopping\n```python\nclass Solution(object):\n    def nthUglyNumber(self, n):\n        \"\"\"\n        (docstring as provided)\n        \"\"\"\n        ugly = [1]\n        i2 = i3 = i5 = 0\n        while True:\n            next2, next3, next5 = 2 * ugly[i2], 3 * ugly[i3], 5 * ugly[i5]\n            next_ugly = min(next2, next3, next5)\n            if len(ugly) == n:\n                return ugly[-1]\n            if next_ugly not in ugly:\n                ugly.append(next_ugly)\n            if next_ugly == next2:\n                i2 += 1\n            elif next_ugly == next3:\n                i3 += 1\n            else:\n                i5 += 1\n```\n\n### Snippet 6: Using a Priority Queue with a Twist\n```python\nimport heapq\n\nclass Solution(object):\n    def nthUglyNumber(self, n):\n        \"\"\"\n        (docstring as provided)\n        \"\"\"\n        heap = [1]\n        seen\n\n = {1}\n        factors = [2, 3, 5]\n\n        for _ in range(n):\n            current = heapq.heappop(heap)\n            for factor in factors:\n                new_ugly = current * factor\n                if new_ugly not in seen:\n                    seen.add(new_ugly)\n                    heapq.heappush(heap, new_ugly)\n\n        return current\n```\n\n### Snippet 7: Space Optimized Dynamic Programming\n```python\nclass Solution(object):\n    def nthUglyNumber(self, n):\n        \"\"\"\n        (docstring as provided)\n        \"\"\"\n        ugly = [1] * n\n        i2 = i3 = i5 = 0\n\n        for i in range(1, n):\n            min_val = min(2 * ugly[i2], 3 * ugly[i3], 5 * ugly[i5])\n            ugly[i] = min_val\n\n            if min_val == 2 * ugly[i2]:\n                i2 += 1\n            if min_val == 3 * ugly[i3]:\n                i3 += 1\n            if min_val == 5 * ugly[i5]:\n                i5 += 1\n\n        return ugly[-1]\n```\n\n### Snippet 8: Generator Function\n```python\nclass Solution(object):\n    def nthUglyNumber(self, n):\n        \"\"\"\n        (docstring as provided)\n        \"\"\"\n        def generate_ugly():\n            yield 1\n            ugly = [1]\n            i2 = i3 = i5 = 0\n            while True:\n                next_ugly = min(2 * ugly[i2], 3 * ugly[i3], 5 * ugly[i5])\n                yield next_ugly\n                if next_ugly == 2 * ugly[i2]:\n                    i2 += 1\n                if next_ugly == 3 * ugly[i3]:\n                    i3 += 1\n                if next_ugly == 5 * ugly[i5]:\n                    i5 += 1\n                ugly.append(next_ugly)\n\n        ugly_gen = generate_ugly()\n        for _ in range(n):\n            result = next(ugly_gen)\n        return result\n```\n\n### Snippet 9: Using Binary Search for Optimization\n```python\nclass Solution(object):\n    def nthUglyNumber(self, n):\n        \"\"\"\n        (docstring as provided)\n        \"\"\"\n        def is_ugly(num):\n            for p in [2, 3, 5]:\n                while num % p == 0:\n                    num //= p\n            return num == 1\n\n        left, right = 1, n * 5\n        while left < right:\n            mid = (left + right) // 2\n            count = sum(mid // i for i in [2, 3, 5])\n            if count < n:\n                left = mid + 1\n            else:\n                right = mid\n        return left\n```\n\n### Snippet 10: Using Function Decorators for Caching\n```python\nfrom functools import lru_cache\n\nclass Solution(object):\n    def nthUglyNumber(self, n):\n        \"\"\"\n        (docstring as provided)\n        \"\"\"\n        @lru_cache(maxsize=None)\n        def compute_ugly(k):\n            if k == 1: return 1\n            return min(compute_ugly(k // 2) * 2, compute_ugly(k // 3) * 3, compute_ugly(k // 5) * 5)\n\n        result = 1\n        for i in range(2, n + 1):\n            result = compute_ugly(i)\n        return result\n```\n\nEach of these snippets implements a different strategy to solve the problem, demonstrating various concepts like dynamic programming, heap data structures, set operations, recursion, memoization, and more."
}