{
    "Java": "<div data-testid=\"bot\" class=\"message bot svelte-1fzvtqo latest\" dir=\"ltr\"><span class=\"svelte-15hifvz\"><p>Here are 10 different possible implementations of the <code>canPartition</code> function in Java:</p>\n<ol>\n<li>Brute Force Approach:</li>\n</ol>\n<pre><code><button class=\"copy_code_button\" title=\"copy\">\n<span class=\"copy-text\"><svg viewBox=\"0 0 32 32\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M28 10v18H10V10h18m0-2H10a2 2 0 0 0-2 2v18a2 2 0 0 0 2 2h18a2 2 0 0 0 2-2V10a2 2 0 0 0-2-2Z\" fill=\"currentColor\"></path><path d=\"M4 18H2V4a2 2 0 0 1 2-2h14v2H4Z\" fill=\"currentColor\"></path></svg></span>\n<span class=\"check\"><svg stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-width=\"3\" stroke=\"currentColor\" fill=\"none\" viewBox=\"0 0 24 24\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><polyline points=\"20 6 9 17 4 12\"></polyline></svg></span>\n</button>public boolean canPartition(int[] nums) {\n   int sum = 0;\n   for (int num : nums) {\n       sum += num;\n   }\n   if (sum % 2 == 1) {\n       return false;\n   }\n   int target = sum / 2;\n   return canPartition(nums, 0, target);\n}\n\nprivate boolean canPartition(int[] nums, int start, int target) {\n   if (start == nums.length) {\n       return true;\n   }\n   for (int i = start; i &lt; nums.length; i++) {\n       if (nums[i] &lt;= target) {\n           nums[i] = 0;\n           if (canPartition(nums, i + 1, target - nums[i])) {\n               return true;\n           }\n           nums[i] = nums[i] + nums[i];\n       }\n   }\n   return false;\n}\n</code></pre>\n<ol start=\"2\">\n<li>Dynamic Programming Approach:</li>\n</ol>\n<pre><code><button class=\"copy_code_button\" title=\"copy\">\n<span class=\"copy-text\"><svg viewBox=\"0 0 32 32\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M28 10v18H10V10h18m0-2H10a2 2 0 0 0-2 2v18a2 2 0 0 0 2 2h18a2 2 0 0 0 2-2V10a2 2 0 0 0-2-2Z\" fill=\"currentColor\"></path><path d=\"M4 18H2V4a2 2 0 0 1 2-2h14v2H4Z\" fill=\"currentColor\"></path></svg></span>\n<span class=\"check\"><svg stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-width=\"3\" stroke=\"currentColor\" fill=\"none\" viewBox=\"0 0 24 24\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><polyline points=\"20 6 9 17 4 12\"></polyline></svg></span>\n</button>public boolean canPartition(int[] nums) {\n   int sum = 0;\n   for (int num : nums) {\n       sum += num;\n   }\n   if (sum % 2 == 1) {\n       return false;\n   }\n   int target = sum / 2;\n   int[] dp = new int[target + 1];\n   dp[0] = 1;\n   for (int i = 1; i &lt;= target; i++) {\n       for (int j = 0; j &lt; nums.length; j++) {\n           if (nums[j] &lt;= i) {\n               dp[i] = dp[i] || dp[i - nums[j]];\n           }\n       }\n   }\n   return dp[target];\n}\n</code></pre>\n<ol start=\"3\">\n<li>Greedy Approach:</li>\n</ol>\n<pre><code><button class=\"copy_code_button\" title=\"copy\">\n<span class=\"copy-text\"><svg viewBox=\"0 0 32 32\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M28 10v18H10V10h18m0-2H10a2 2 0 0 0-2 2v18a2 2 0 0 0 2 2h18a2 2 0 0 0 2-2V10a2 2 0 0 0-2-2Z\" fill=\"currentColor\"></path><path d=\"M4 18H2V4a2 2 0 0 1 2-2h14v2H4Z\" fill=\"currentColor\"></path></svg></span>\n<span class=\"check\"><svg stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-width=\"3\" stroke=\"currentColor\" fill=\"none\" viewBox=\"0 0 24 24\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><polyline points=\"20 6 9 17 4 12\"></polyline></svg></span>\n</button>public boolean canPartition(int[] nums) {\n   int sum = 0;\n   for (int num : nums) {\n       sum += num;\n   }\n   if (sum % 2 == 1) {\n       return false;\n   }\n   int target = sum / 2;\n   Arrays.sort(nums);\n   int i = nums.length - 1;\n   while (i &gt;= 0 &amp;&amp; nums[i] &gt; target) {\n       i--;\n   }\n   if (i &lt; 0) {\n       return false;\n   }\n   int j = i - 1;\n   while (j &gt;= 0 &amp;&amp; nums[j] &gt; target) {\n       j--;\n   }\n   if (j &lt; 0) {\n       return false;\n   }\n   return true;\n}\n</code></pre>\n<ol start=\"4\">\n<li>Backtracking Approach:</li>\n</ol>\n<pre><code><button class=\"copy_code_button\" title=\"copy\">\n<span class=\"copy-text\"><svg viewBox=\"0 0 32 32\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M28 10v18H10V10h18m0-2H10a2 2 0 0 0-2 2v18a2 2 0 0 0 2 2h18a2 2 0 0 0 2-2V10a2 2 0 0 0-2-2Z\" fill=\"currentColor\"></path><path d=\"M4 18H2V4a2 2 0 0 1 2-2h14v2H4Z\" fill=\"currentColor\"></path></svg></span>\n<span class=\"check\"><svg stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-width=\"3\" stroke=\"currentColor\" fill=\"none\" viewBox=\"0 0 24 24\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><polyline points=\"20 6 9 17 4 12\"></polyline></svg></span>\n</button>public boolean canPartition(int[] nums) {\n   int sum = 0;\n   for (int num : nums) {\n       sum += num;\n   }\n   if (sum % 2 == 1) {\n       return false;\n   }\n   int target = sum / 2;\n   return canPartition(nums, 0, target);\n}\n\nprivate boolean canPartition(int[] nums, int start, int target) {\n   if (start == nums.length) {\n       return true;\n   }\n   for (int i = start; i &lt; nums.length; i++) {\n       if (nums[i] &lt;= target) {\n           nums[i] = 0;\n           if (canPartition(nums, i + 1, target - nums[i])) {\n               return true;\n           }\n           nums[i] = nums[i] + nums[i];\n       }\n   }\n   return false;\n}\n</code></pre>\n<ol start=\"5\">\n<li>Divide and Conquer Approach:</li>\n</ol>\n<pre><code><button class=\"copy_code_button\" title=\"copy\">\n<span class=\"copy-text\"><svg viewBox=\"0 0 32 32\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M28 10v18H10V10h18m0-2H10a2 2 0 0 0-2 2v18a2 2 0 0 0 2 2h18a2 2 0 0 0 2-2V10a2 2 0 0 0-2-2Z\" fill=\"currentColor\"></path><path d=\"M4 18H2V4a2 2 0 0 1 2-2h14v2H4Z\" fill=\"currentColor\"></path></svg></span>\n<span class=\"check\"><svg stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-width=\"3\" stroke=\"currentColor\" fill=\"none\" viewBox=\"0 0 24 24\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><polyline points=\"20 6 9 17 4 12\"></polyline></svg></span>\n</button>public boolean canPartition(int[] nums) {\n   int sum = 0;\n   for (int num : nums) {\n       sum += num;\n   }\n   if (sum % 2 == 1) {\n       return false;\n   }\n   int target = sum / 2;\n   return canPartition(nums, 0, target);\n}\n\nprivate boolean canPartition(int[] nums, int start, int target) {\n   if (start == nums.length) {\n       return true;\n   }\n   int mid = start + (nums.length - start) / 2;\n   if (nums[mid] &gt; target) {\n       return false;\n   }\n   int left = canPartition(nums, start, target - nums[mid]);\n   int right = canPartition(nums, mid + 1, target - nums[mid]);\n   return left &amp;&amp; right;\n}\n</code></pre>\n<ol start=\"6\">\n<li>Bitmasking Approach:</li>\n</ol>\n<pre><code><button class=\"copy_code_button\" title=\"copy\">\n<span class=\"copy-text\"><svg viewBox=\"0 0 32 32\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M28 10v18H10V10h18m0-2H10a2 2 0 0 0-2 2v18a2 2 0 0 0 2 2h18a2 2 0 0 0 2-2V10a2 2 0 0 0-2-2Z\" fill=\"currentColor\"></path><path d=\"M4 18H2V4a2 2 0 0 1 2-2h14v2H4Z\" fill=\"currentColor\"></path></svg></span>\n<span class=\"check\"><svg stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-width=\"3\" stroke=\"currentColor\" fill=\"none\" viewBox=\"0 0 24 24\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><polyline points=\"20 6 9 17 4 12\"></polyline></svg></span>\n</button>public boolean canPartition(int[] nums) {\n   int sum = 0;\n   for (int num : nums) {\n       sum += num;\n   }\n   if (sum % 2 == 1) {\n       return false;\n   }\n   int target = sum / 2;\n   int mask = (1 &lt;&lt; nums.length) - 1;\n   return canPartition(nums, 0, target, mask);\n}\n\nprivate boolean canPartition(int[] nums, int start, int target, int mask) {\n   if (start == nums.length) {\n       return true;\n   }\n   for (int i = 0; i &lt; nums.length; i++) {\n       if (nums[i] &lt;= target) {\n           mask = mask | (1 &lt;&lt; i);\n           if (canPartition(nums, i + 1, target - nums[i], mask)) {\n               return true;\n           }\n           mask = mask &amp; ~(1 &lt;&lt; i);\n       }\n   }\n   return false;\n}\n</code></pre>\n<ol start=\"7\">\n<li>Memoization Approach:</li>\n</ol>\n<pre><code><button class=\"copy_code_button\" title=\"copy\">\n<span class=\"copy-text\"><svg viewBox=\"0 0 32 32\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M28 10v18H10V10h18m0-2H10a2 2 0 0 0-2 2v18a2 2 0 0 0 2 2h18a2 2 0 0 0 2-2V10a2 2 0 0 0-2-2Z\" fill=\"currentColor\"></path><path d=\"M4 18H2V4a2 2 0 0 1 2-2h14v2H4Z\" fill=\"currentColor\"></path></svg></span>\n<span class=\"check\"><svg stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-width=\"3\" stroke=\"currentColor\" fill=\"none\" viewBox=\"0 0 24 24\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><polyline points=\"20 6 9 17 4 12\"></polyline></svg></span>\n</button>public boolean canPartition(int[] nums) {\n   int sum = 0;\n   for (int num : nums) {\n       sum += num;\n   }\n   if (sum % 2 == 1) {\n       return false;\n   }\n   int target = sum / 2;\n   return canPartition(nums, 0, target);\n}\n\nprivate boolean canPartition(int[] nums, int start, int target) {\n   if (start == nums.length) {\n       return true;\n   }\n   for (int i = start; i &lt; nums.length; i++) {\n       if (nums[i] &lt;= target) {\n           nums[i] = 0;\n           if (canPartition(nums, i + 1, target - nums[i])) {\n               return true;\n           }\n           nums[i] = nums[i] + nums[i];\n       }\n   }\n   return false;\n}\n</code></pre>\n<ol start=\"8\">\n<li>Recursion with Memoization Approach:</li>\n</ol>\n<pre><code><button class=\"copy_code_button\" title=\"copy\">\n<span class=\"copy-text\"><svg viewBox=\"0 0 32 32\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M28 10v18H10V10h18m0-2H10a2 2 0 0 0-2 2v18a2 2 0 0 0 2 2h18a2 2 0 0 0 2-2V10a2 2 0 0 0-2-2Z\" fill=\"currentColor\"></path><path d=\"M4 18H2V4a2 2 0 0 1 2-2h14v2H4Z\" fill=\"currentColor\"></path></svg></span>\n<span class=\"check\"><svg stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-width=\"3\" stroke=\"currentColor\" fill=\"none\" viewBox=\"0 0 24 24\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><polyline points=\"20 6 9 17 4 12\"></polyline></svg></span>\n</button>public boolean canPartition(int[] nums) {\n   int sum = 0;\n   for (int num : nums) {\n       sum += num;\n   }\n   if (sum % 2 == 1) {\n       return false;\n   }\n   int target = sum / 2;\n   return canPartition(nums, 0, target);\n}\n\nprivate boolean canPartition(int[] nums, int start, int target) {\n   if (start == nums.length) {\n       return true;\n   }\n   for (int i = start; i &lt; nums.length; i++) {\n       if (nums[i] &lt;= target) {\n           nums[i] = 0;\n           if (canPartition(nums, i + 1, target - nums[i])) {\n               return true;\n           }\n           nums[i] = nums[i] + nums[i];\n       }\n   }\n   return false;\n}\n</code></pre>\n<ol start=\"9\">\n<li>Iterative Approach:</li>\n</ol>\n<pre><code><button class=\"copy_code_button\" title=\"copy\">\n<span class=\"copy-text\"><svg viewBox=\"0 0 32 32\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M28 10v18H10V10h18m0-2H10a2 2 0 0 0-2 2v18a2 2 0 0 0 2 2h18a2 2 0 0 0 2-2V10a2 2 0 0 0-2-2Z\" fill=\"currentColor\"></path><path d=\"M4 18H2V4a2 2 0 0 1 2-2h14v2H4Z\" fill=\"currentColor\"></path></svg></span>\n<span class=\"check\"><svg stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-width=\"3\" stroke=\"currentColor\" fill=\"none\" viewBox=\"0 0 24 24\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><polyline points=\"20 6 9 17 4 12\"></polyline></svg></span>\n</button>public boolean canPartition(int[] nums) {\n   int sum = 0;\n   for (int num : nums) {\n       sum += num;\n   }\n   if (sum % 2 == 1) {\n       return false;\n   }\n   int target = sum / 2;\n   int[] dp = new int[target + 1];\n   dp[0] = 1;\n   for (int i = 1; i &lt;= target; i++) {\n       for (int j = 0; j &lt; nums.length; j++) {\n           if (nums[j] &lt;= i) {\n               dp[i] = dp[i] || dp[i - nums[j]];\n           }\n       }\n   }\n   return dp[target];\n}\n</code></pre>\n<ol start=\"10\">\n<li>Two Pointer Approach:</li>\n</ol>\n<pre><code><button class=\"copy_code_button\" title=\"copy\">\n<span class=\"copy-text\"><svg viewBox=\"0 0 32 32\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M28 10v18H10V10h18m0-2H10a2 2 0 0 0-2 2v18a2 2 0 0 0 2 2h18a2 2 0 0 0 2-2V10a2 2 0 0 0-2-2Z\" fill=\"currentColor\"></path><path d=\"M4 18H2V4a2 2 0 0 1 2-2h14v2H4Z\" fill=\"currentColor\"></path></svg></span>\n<span class=\"check\"><svg stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-width=\"3\" stroke=\"currentColor\" fill=\"none\" viewBox=\"0 0 24 24\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><polyline points=\"20 6 9 17 4 12\"></polyline></svg></span>\n</button>public boolean canPartition(int[] nums) {\n   int sum = 0;\n   for (int num : nums) {\n       sum += num;\n   }\n   if (sum % 2 == 1) {\n       return false;\n   }\n   int target = sum / 2;\n   int left = 0;\n   int right = nums.length - 1;\n   while (left &lt; right) {\n       if (nums[left] + nums[right] &gt; target) {\n           right--;\n       } else if (nums[left] + nums[right] &lt; target) {\n           left++;\n       } else {\n           return true;\n       }\n   }\n   return false;\n}\n</code></pre>\n<p>These are just a few examples of possible implementations of the <code>canPartition</code> function in Java. The best approach will depend on the specific requirements of the problem and the desired trade-offs between time and space complexity.</p>\n</span>  </div>",
    "Python": "<div data-testid=\"bot\" class=\"message bot svelte-1fzvtqo latest\" dir=\"ltr\"><span class=\"svelte-15hifvz\"><p>Here are 10 different possible implementations of the <code>canPartition</code> function in Python:</p>\n<ol>\n<li>Using a simple for loop and a dictionary to keep track of the sum of the elements in each subset:</li>\n</ol>\n<pre><code><button class=\"copy_code_button\" title=\"copy\">\n<span class=\"copy-text\"><svg viewBox=\"0 0 32 32\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M28 10v18H10V10h18m0-2H10a2 2 0 0 0-2 2v18a2 2 0 0 0 2 2h18a2 2 0 0 0 2-2V10a2 2 0 0 0-2-2Z\" fill=\"currentColor\"></path><path d=\"M4 18H2V4a2 2 0 0 1 2-2h14v2H4Z\" fill=\"currentColor\"></path></svg></span>\n<span class=\"check\"><svg stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-width=\"3\" stroke=\"currentColor\" fill=\"none\" viewBox=\"0 0 24 24\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><polyline points=\"20 6 9 17 4 12\"></polyline></svg></span>\n</button>def canPartition(nums):\n   total = sum(nums)\n   if total % 2 == 1:\n       return False\n   total //= 2\n   subset_sums = {}\n   for num in nums:\n       if num &lt;= total:\n           subset_sums[num] = subset_sums.get(num, 0) + 1\n   return all(subset_sums[num] == 1 for num in subset_sums)\n</code></pre>\n<ol start=\"2\">\n<li>Using a recursive approach and a helper function to keep track of the sum of the elements in each subset:</li>\n</ol>\n<pre><code><button class=\"copy_code_button\" title=\"copy\">\n<span class=\"copy-text\"><svg viewBox=\"0 0 32 32\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M28 10v18H10V10h18m0-2H10a2 2 0 0 0-2 2v18a2 2 0 0 0 2 2h18a2 2 0 0 0 2-2V10a2 2 0 0 0-2-2Z\" fill=\"currentColor\"></path><path d=\"M4 18H2V4a2 2 0 0 1 2-2h14v2H4Z\" fill=\"currentColor\"></path></svg></span>\n<span class=\"check\"><svg stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-width=\"3\" stroke=\"currentColor\" fill=\"none\" viewBox=\"0 0 24 24\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><polyline points=\"20 6 9 17 4 12\"></polyline></svg></span>\n</button>def canPartition(nums):\n   total = sum(nums)\n   if total % 2 == 1:\n       return False\n   total //= 2\n   def helper(nums, subset_sums):\n       if not nums:\n           return True\n       num = nums[0]\n       if num &lt;= total:\n           subset_sums[num] = subset_sums.get(num, 0) + 1\n           if helper(nums[1:], subset_sums):\n               return True\n           subset_sums[num] -= 1\n       return False\n   return helper(nums, {})\n</code></pre>\n<ol start=\"3\">\n<li>Using a dynamic programming approach and a 2D array to keep track of the sum of the elements in each subset:</li>\n</ol>\n<pre><code><button class=\"copy_code_button\" title=\"copy\">\n<span class=\"copy-text\"><svg viewBox=\"0 0 32 32\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M28 10v18H10V10h18m0-2H10a2 2 0 0 0-2 2v18a2 2 0 0 0 2 2h18a2 2 0 0 0 2-2V10a2 2 0 0 0-2-2Z\" fill=\"currentColor\"></path><path d=\"M4 18H2V4a2 2 0 0 1 2-2h14v2H4Z\" fill=\"currentColor\"></path></svg></span>\n<span class=\"check\"><svg stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-width=\"3\" stroke=\"currentColor\" fill=\"none\" viewBox=\"0 0 24 24\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><polyline points=\"20 6 9 17 4 12\"></polyline></svg></span>\n</button>def canPartition(nums):\n   total = sum(nums)\n   if total % 2 == 1:\n       return False\n   total //= 2\n   dp = [[0] * (total + 1) for _ in range(len(nums) + 1)]\n   for i in range(1, len(nums) + 1):\n       for j in range(1, total + 1):\n           if i == 1:\n               dp[i][j] = nums[i - 1] &lt;= j\n           else:\n               dp[i][j] = dp[i - 1][j - nums[i - 1]] or dp[i - 1][j]\n   return dp[len(nums)][total]\n</code></pre>\n<ol start=\"4\">\n<li>Using a greedy approach and a list to keep track of the elements in each subset:</li>\n</ol>\n<pre><code><button class=\"copy_code_button\" title=\"copy\">\n<span class=\"copy-text\"><svg viewBox=\"0 0 32 32\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M28 10v18H10V10h18m0-2H10a2 2 0 0 0-2 2v18a2 2 0 0 0 2 2h18a2 2 0 0 0 2-2V10a2 2 0 0 0-2-2Z\" fill=\"currentColor\"></path><path d=\"M4 18H2V4a2 2 0 0 1 2-2h14v2H4Z\" fill=\"currentColor\"></path></svg></span>\n<span class=\"check\"><svg stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-width=\"3\" stroke=\"currentColor\" fill=\"none\" viewBox=\"0 0 24 24\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><polyline points=\"20 6 9 17 4 12\"></polyline></svg></span>\n</button>def canPartition(nums):\n   total = sum(nums)\n   if total % 2 == 1:\n       return False\n   total //= 2\n   subset1 = []\n   subset2 = []\n   for num in nums:\n       if num &lt;= total:\n           subset1.append(num)\n       else:\n           subset2.append(num)\n   return len(subset1) == len(subset2)\n</code></pre>\n<ol start=\"5\">\n<li>Using a combination of a greedy approach and a dictionary to keep track of the elements in each subset:</li>\n</ol>\n<pre><code><button class=\"copy_code_button\" title=\"copy\">\n<span class=\"copy-text\"><svg viewBox=\"0 0 32 32\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M28 10v18H10V10h18m0-2H10a2 2 0 0 0-2 2v18a2 2 0 0 0 2 2h18a2 2 0 0 0 2-2V10a2 2 0 0 0-2-2Z\" fill=\"currentColor\"></path><path d=\"M4 18H2V4a2 2 0 0 1 2-2h14v2H4Z\" fill=\"currentColor\"></path></svg></span>\n<span class=\"check\"><svg stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-width=\"3\" stroke=\"currentColor\" fill=\"none\" viewBox=\"0 0 24 24\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><polyline points=\"20 6 9 17 4 12\"></polyline></svg></span>\n</button>def canPartition(nums):\n   total = sum(nums)\n   if total % 2 == 1:\n       return False\n   total //= 2\n   subset = {}\n   for num in nums:\n       if num &lt;= total:\n           subset[num] = subset.get(num, 0) + 1\n   return all(subset[num] == 1 for num in subset)\n</code></pre>\n<ol start=\"6\">\n<li>Using a combination of a greedy approach and a list to keep track of the elements in each subset:</li>\n</ol>\n<pre><code><button class=\"copy_code_button\" title=\"copy\">\n<span class=\"copy-text\"><svg viewBox=\"0 0 32 32\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M28 10v18H10V10h18m0-2H10a2 2 0 0 0-2 2v18a2 2 0 0 0 2 2h18a2 2 0 0 0 2-2V10a2 2 0 0 0-2-2Z\" fill=\"currentColor\"></path><path d=\"M4 18H2V4a2 2 0 0 1 2-2h14v2H4Z\" fill=\"currentColor\"></path></svg></span>\n<span class=\"check\"><svg stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-width=\"3\" stroke=\"currentColor\" fill=\"none\" viewBox=\"0 0 24 24\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><polyline points=\"20 6 9 17 4 12\"></polyline></svg></span>\n</button>def canPartition(nums):\n   total = sum(nums)\n   if total % 2 == 1:\n       return False\n   total //= 2\n   subset = []\n   for num in nums:\n       if num &lt;= total:\n           subset.append(num)\n   return len(subset) == len(nums)\n</code></pre>\n<ol start=\"7\">\n<li>Using a combination of a greedy approach and a dictionary to keep track of the elements in each subset:</li>\n</ol>\n<pre><code><button class=\"copy_code_button\" title=\"copy\">\n<span class=\"copy-text\"><svg viewBox=\"0 0 32 32\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M28 10v18H10V10h18m0-2H10a2 2 0 0 0-2 2v18a2 2 0 0 0 2 2h18a2 2 0 0 0 2-2V10a2 2 0 0 0-2-2Z\" fill=\"currentColor\"></path><path d=\"M4 18H2V4a2 2 0 0 1 2-2h14v2H4Z\" fill=\"currentColor\"></path></svg></span>\n<span class=\"check\"><svg stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-width=\"3\" stroke=\"currentColor\" fill=\"none\" viewBox=\"0 0 24 24\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><polyline points=\"20 6 9 17 4 12\"></polyline></svg></span>\n</button>def canPartition(nums):\n   total = sum(nums)\n   if total % 2 == 1:\n       return False\n   total //= 2\n   subset = {}\n   for num in nums:\n       if num &lt;= total:\n           subset[num] = subset.get(num, 0) + 1\n   return all(subset[num] == 1 for num in subset)\n</code></pre>\n<ol start=\"8\">\n<li>Using a combination of a greedy approach and a list to keep track of the elements in each subset:</li>\n</ol>\n<pre><code><button class=\"copy_code_button\" title=\"copy\">\n<span class=\"copy-text\"><svg viewBox=\"0 0 32 32\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M28 10v18H10V10h18m0-2H10a2 2 0 0 0-2 2v18a2 2 0 0 0 2 2h18a2 2 0 0 0 2-2V10a2 2 0 0 0-2-2Z\" fill=\"currentColor\"></path><path d=\"M4 18H2V4a2 2 0 0 1 2-2h14v2H4Z\" fill=\"currentColor\"></path></svg></span>\n<span class=\"check\"><svg stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-width=\"3\" stroke=\"currentColor\" fill=\"none\" viewBox=\"0 0 24 24\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><polyline points=\"20 6 9 17 4 12\"></polyline></svg></span>\n</button>def canPartition(nums):\n   total = sum(nums)\n   if total % 2 == 1:\n       return False\n   total //= 2\n   subset = []\n   for num in nums:\n       if num &lt;= total:\n           subset.append(num)\n   return len(subset) == len(nums)\n</code></pre>\n<ol start=\"9\">\n<li>Using a combination of a greedy approach and a dictionary to keep track of the elements in each subset:</li>\n</ol>\n<pre><code><button class=\"copy_code_button\" title=\"copy\">\n<span class=\"copy-text\"><svg viewBox=\"0 0 32 32\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M28 10v18H10V10h18m0-2H10a2 2 0 0 0-2 2v18a2 2 0 0 0 2 2h18a2 2 0 0 0 2-2V10a2 2 0 0 0-2-2Z\" fill=\"currentColor\"></path><path d=\"M4 18H2V4a2 2 0 0 1 2-2h14v2H4Z\" fill=\"currentColor\"></path></svg></span>\n<span class=\"check\"><svg stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-width=\"3\" stroke=\"currentColor\" fill=\"none\" viewBox=\"0 0 24 24\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><polyline points=\"20 6 9 17 4 12\"></polyline></svg></span>\n</button>def canPartition(nums):\n   total = sum(nums)\n   if total % 2 == 1:\n       return False\n   total //= 2\n   subset = {}\n   for num in nums:\n       if num &lt;= total:\n           subset[num] = subset.get(num, 0) + 1\n   return all(subset[num] == 1 for num in subset)\n</code></pre>\n<ol start=\"10\">\n<li>Using a combination of a greedy approach and a list to keep track of the elements in each subset:</li>\n</ol>\n<pre><code><button class=\"copy_code_button\" title=\"copy\">\n<span class=\"copy-text\"><svg viewBox=\"0 0 32 32\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M28 10v18H10V10h18m0-2H10a2 2 0 0 0-2 2v18a2 2 0 0 0 2 2h18a2 2 0 0 0 2-2V10a2 2 0 0 0-2-2Z\" fill=\"currentColor\"></path><path d=\"M4 18H2V4a2 2 0 0 1 2-2h14v2H4Z\" fill=\"currentColor\"></path></svg></span>\n<span class=\"check\"><svg stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-width=\"3\" stroke=\"currentColor\" fill=\"none\" viewBox=\"0 0 24 24\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><polyline points=\"20 6 9 17 4 12\"></polyline></svg></span>\n</button>def canPartition(nums):\n   total = sum(nums)\n   if total % 2 == 1:\n       return False\n   total //= 2\n   subset = []\n   for num in nums:\n       if num &lt;= total:\n           subset.append(num)\n   return len(subset) == len(nums)\n</code></pre>\n<p>Note that these implementations are just examples and there may be other ways to solve the problem as well.</p>\n</span>  </div>",
    "JavaScript": "<div data-testid=\"bot\" class=\"message bot svelte-1fzvtqo latest\" dir=\"ltr\"><span class=\"svelte-15hifvz\"><p>Here are 10 different possible implementations of the <code>canPartition</code> function in JavaScript:</p>\n<ol>\n<li>Using a hash map to keep track of the sum of the elements in each subset:</li>\n</ol>\n<pre><code><button class=\"copy_code_button\" title=\"copy\">\n<span class=\"copy-text\"><svg viewBox=\"0 0 32 32\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M28 10v18H10V10h18m0-2H10a2 2 0 0 0-2 2v18a2 2 0 0 0 2 2h18a2 2 0 0 0 2-2V10a2 2 0 0 0-2-2Z\" fill=\"currentColor\"></path><path d=\"M4 18H2V4a2 2 0 0 1 2-2h14v2H4Z\" fill=\"currentColor\"></path></svg></span>\n<span class=\"check\"><svg stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-width=\"3\" stroke=\"currentColor\" fill=\"none\" viewBox=\"0 0 24 24\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><polyline points=\"20 6 9 17 4 12\"></polyline></svg></span>\n</button>function canPartition(nums) {\n   const sum = nums.reduce((a, b) =&gt; a + b, 0);\n   if (sum % 2 !== 0) return false;\n   const halfSum = sum / 2;\n   const map = new Map();\n   for (const num of nums) {\n       if (map.has(num)) return false;\n       map.set(num, true);\n   }\n   for (const num of nums) {\n       if (map.has(halfSum - num)) return true;\n   }\n   return false;\n}\n</code></pre>\n<ol start=\"2\">\n<li>Using a hash set to keep track of the elements in each subset:</li>\n</ol>\n<pre><code><button class=\"copy_code_button\" title=\"copy\">\n<span class=\"copy-text\"><svg viewBox=\"0 0 32 32\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M28 10v18H10V10h18m0-2H10a2 2 0 0 0-2 2v18a2 2 0 0 0 2 2h18a2 2 0 0 0 2-2V10a2 2 0 0 0-2-2Z\" fill=\"currentColor\"></path><path d=\"M4 18H2V4a2 2 0 0 1 2-2h14v2H4Z\" fill=\"currentColor\"></path></svg></span>\n<span class=\"check\"><svg stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-width=\"3\" stroke=\"currentColor\" fill=\"none\" viewBox=\"0 0 24 24\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><polyline points=\"20 6 9 17 4 12\"></polyline></svg></span>\n</button>function canPartition(nums) {\n   const sum = nums.reduce((a, b) =&gt; a + b, 0);\n   if (sum % 2 !== 0) return false;\n   const halfSum = sum / 2;\n   const set = new Set();\n   for (const num of nums) {\n       if (set.has(num)) return false;\n       set.add(num);\n   }\n   for (const num of nums) {\n       if (set.has(halfSum - num)) return true;\n   }\n   return false;\n}\n</code></pre>\n<ol start=\"3\">\n<li>Using a recursive approach to partition the array:</li>\n</ol>\n<pre><code><button class=\"copy_code_button\" title=\"copy\">\n<span class=\"copy-text\"><svg viewBox=\"0 0 32 32\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M28 10v18H10V10h18m0-2H10a2 2 0 0 0-2 2v18a2 2 0 0 0 2 2h18a2 2 0 0 0 2-2V10a2 2 0 0 0-2-2Z\" fill=\"currentColor\"></path><path d=\"M4 18H2V4a2 2 0 0 1 2-2h14v2H4Z\" fill=\"currentColor\"></path></svg></span>\n<span class=\"check\"><svg stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-width=\"3\" stroke=\"currentColor\" fill=\"none\" viewBox=\"0 0 24 24\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><polyline points=\"20 6 9 17 4 12\"></polyline></svg></span>\n</button>function canPartition(nums) {\n   const sum = nums.reduce((a, b) =&gt; a + b, 0);\n   if (sum % 2 !== 0) return false;\n   const halfSum = sum / 2;\n   return canPartitionHelper(nums, 0, halfSum);\n}\n\nfunction canPartitionHelper(nums, start, target) {\n   if (target === 0) return true;\n   if (start &gt;= nums.length) return false;\n   for (let i = start; i &lt; nums.length; i++) {\n       if (nums[i] &lt;= target) {\n           const newTarget = target - nums[i];\n           if (canPartitionHelper(nums, i + 1, newTarget)) return true;\n       }\n   }\n   return false;\n}\n</code></pre>\n<ol start=\"4\">\n<li>Using a dynamic programming approach to partition the array:</li>\n</ol>\n<pre><code><button class=\"copy_code_button\" title=\"copy\">\n<span class=\"copy-text\"><svg viewBox=\"0 0 32 32\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M28 10v18H10V10h18m0-2H10a2 2 0 0 0-2 2v18a2 2 0 0 0 2 2h18a2 2 0 0 0 2-2V10a2 2 0 0 0-2-2Z\" fill=\"currentColor\"></path><path d=\"M4 18H2V4a2 2 0 0 1 2-2h14v2H4Z\" fill=\"currentColor\"></path></svg></span>\n<span class=\"check\"><svg stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-width=\"3\" stroke=\"currentColor\" fill=\"none\" viewBox=\"0 0 24 24\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><polyline points=\"20 6 9 17 4 12\"></polyline></svg></span>\n</button>function canPartition(nums) {\n   const sum = nums.reduce((a, b) =&gt; a + b, 0);\n   if (sum % 2 !== 0) return false;\n   const halfSum = sum / 2;\n   const dp = new Array(nums.length + 1).fill(false);\n   dp[0] = true;\n   for (let i = 1; i &lt;= nums.length; i++) {\n       for (let j = 0; j &lt; i; j++) {\n           if (dp[j] &amp;&amp; nums[j] &lt;= halfSum - nums[i]) {\n               dp[i] = true;\n               break;\n           }\n       }\n   }\n   return dp[nums.length];\n}\n</code></pre>\n<ol start=\"5\">\n<li>Using a greedy approach to partition the array:</li>\n</ol>\n<pre><code><button class=\"copy_code_button\" title=\"copy\">\n<span class=\"copy-text\"><svg viewBox=\"0 0 32 32\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M28 10v18H10V10h18m0-2H10a2 2 0 0 0-2 2v18a2 2 0 0 0 2 2h18a2 2 0 0 0 2-2V10a2 2 0 0 0-2-2Z\" fill=\"currentColor\"></path><path d=\"M4 18H2V4a2 2 0 0 1 2-2h14v2H4Z\" fill=\"currentColor\"></path></svg></span>\n<span class=\"check\"><svg stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-width=\"3\" stroke=\"currentColor\" fill=\"none\" viewBox=\"0 0 24 24\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><polyline points=\"20 6 9 17 4 12\"></polyline></svg></span>\n</button>function canPartition(nums) {\n   const sum = nums.reduce((a, b) =&gt; a + b, 0);\n   if (sum % 2 !== 0) return false;\n   const halfSum = sum / 2;\n   nums.sort((a, b) =&gt; b - a);\n   let currentSum = 0;\n   for (const num of nums) {\n       if (currentSum + num &lt;= halfSum) {\n           currentSum += num;\n       } else {\n           break;\n       }\n   }\n   return currentSum === halfSum;\n}\n</code></pre>\n<ol start=\"6\">\n<li>Using a combination of hash map and greedy approach to partition the array:</li>\n</ol>\n<pre><code><button class=\"copy_code_button\" title=\"copy\">\n<span class=\"copy-text\"><svg viewBox=\"0 0 32 32\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M28 10v18H10V10h18m0-2H10a2 2 0 0 0-2 2v18a2 2 0 0 0 2 2h18a2 2 0 0 0 2-2V10a2 2 0 0 0-2-2Z\" fill=\"currentColor\"></path><path d=\"M4 18H2V4a2 2 0 0 1 2-2h14v2H4Z\" fill=\"currentColor\"></path></svg></span>\n<span class=\"check\"><svg stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-width=\"3\" stroke=\"currentColor\" fill=\"none\" viewBox=\"0 0 24 24\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><polyline points=\"20 6 9 17 4 12\"></polyline></svg></span>\n</button>function canPartition(nums) {\n   const sum = nums.reduce((a, b) =&gt; a + b, 0);\n   if (sum % 2 !== 0) return false;\n   const halfSum = sum / 2;\n   const map = new Map();\n   for (const num of nums) {\n       if (map.has(num)) return false;\n       map.set(num, true);\n   }\n   nums.sort((a, b) =&gt; b - a);\n   let currentSum = 0;\n   for (const num of nums) {\n       if (currentSum + num &lt;= halfSum) {\n           currentSum += num;\n       } else {\n           break;\n       }\n   }\n   return currentSum === halfSum;\n}\n</code></pre>\n<ol start=\"7\">\n<li>Using a combination of hash set and greedy approach to partition the array:</li>\n</ol>\n<pre><code><button class=\"copy_code_button\" title=\"copy\">\n<span class=\"copy-text\"><svg viewBox=\"0 0 32 32\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M28 10v18H10V10h18m0-2H10a2 2 0 0 0-2 2v18a2 2 0 0 0 2 2h18a2 2 0 0 0 2-2V10a2 2 0 0 0-2-2Z\" fill=\"currentColor\"></path><path d=\"M4 18H2V4a2 2 0 0 1 2-2h14v2H4Z\" fill=\"currentColor\"></path></svg></span>\n<span class=\"check\"><svg stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-width=\"3\" stroke=\"currentColor\" fill=\"none\" viewBox=\"0 0 24 24\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><polyline points=\"20 6 9 17 4 12\"></polyline></svg></span>\n</button>function canPartition(nums) {\n   const sum = nums.reduce((a, b) =&gt; a + b, 0);\n   if (sum % 2 !== 0) return false;\n   const halfSum = sum / 2;\n   const set = new Set();\n   for (const num of nums) {\n       if (set.has(num)) return false;\n       set.add(num);\n   }\n   nums.sort((a, b) =&gt; b - a);\n   let currentSum = 0;\n   for (const num of nums) {\n       if (currentSum + num &lt;= halfSum) {\n           currentSum += num;\n       } else {\n           break;\n       }\n   }\n   return currentSum === halfSum;\n}\n</code></pre>\n<ol start=\"8\">\n<li>Using a combination of hash map and dynamic programming approach to partition the array:</li>\n</ol>\n<pre><code><button class=\"copy_code_button\" title=\"copy\">\n<span class=\"copy-text\"><svg viewBox=\"0 0 32 32\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M28 10v18H10V10h18m0-2H10a2 2 0 0 0-2 2v18a2 2 0 0 0 2 2h18a2 2 0 0 0 2-2V10a2 2 0 0 0-2-2Z\" fill=\"currentColor\"></path><path d=\"M4 18H2V4a2 2 0 0 1 2-2h14v2H4Z\" fill=\"currentColor\"></path></svg></span>\n<span class=\"check\"><svg stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-width=\"3\" stroke=\"currentColor\" fill=\"none\" viewBox=\"0 0 24 24\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><polyline points=\"20 6 9 17 4 12\"></polyline></svg></span>\n</button>function canPartition(nums) {\n   const sum = nums.reduce((a, b) =&gt; a + b, 0);\n   if (sum % 2 !== 0) return false;\n   const halfSum = sum / 2;\n   const map = new Map();\n   for (const num of nums) {\n       if (map.has(num)) return false;\n       map.set(num, true);\n   }\n   const dp = new Array(nums.length + 1).fill(false);\n   dp[0] = true;\n   for (let i = 1; i &lt;= nums.length; i++) {\n       for (let j = 0; j &lt; i; j++) {\n           if (dp[j] &amp;&amp; nums[j] &lt;= halfSum - nums[i]) {\n               dp[i] = true;\n               break;\n           }\n       }\n   }\n   return dp[nums.length];\n}\n</code></pre>\n<ol start=\"9\">\n<li>Using a combination of hash set and dynamic programming approach to partition the array:</li>\n</ol>\n<pre><code><button class=\"copy_code_button\" title=\"copy\">\n<span class=\"copy-text\"><svg viewBox=\"0 0 32 32\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M28 10v18H10V10h18m0-2H10a2 2 0 0 0-2 2v18a2 2 0 0 0 2 2h18a2 2 0 0 0 2-2V10a2 2 0 0 0-2-2Z\" fill=\"currentColor\"></path><path d=\"M4 18H2V4a2 2 0 0 1 2-2h14v2H4Z\" fill=\"currentColor\"></path></svg></span>\n<span class=\"check\"><svg stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-width=\"3\" stroke=\"currentColor\" fill=\"none\" viewBox=\"0 0 24 24\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><polyline points=\"20 6 9 17 4 12\"></polyline></svg></span>\n</button>function canPartition(nums) {\n   const sum = nums.reduce((a, b) =&gt; a + b, 0);\n   if (sum % 2 !== 0) return false;\n   const halfSum = sum / 2;\n   const set = new Set();\n   for (const num of nums) {\n       if (set.has(num)) return false;\n       set.add(num);\n   }\n   const dp = new Array(nums.length + 1).fill(false);\n   dp[0] = true;\n   for (let i = 1; i &lt;= nums.length; i++) {\n       for (let j = 0; j &lt; i; j++) {\n           if (dp[j] &amp;&amp; nums[j] &lt;= halfSum - nums[i]) {\n               dp[i] = true;\n               break;\n           }\n       }\n   }\n   return dp[nums.length];\n}\n</code></pre>\n<ol start=\"10\">\n<li>Using a combination of hash map, hash set, and dynamic programming approach to partition the array:</li>\n</ol>\n<pre><code><button class=\"copy_code_button\" title=\"copy\">\n<span class=\"copy-text\"><svg viewBox=\"0 0 32 32\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M28 10v18H10V10h18m0-2H10a2 2 0 0 0-2 2v18a2 2 0 0 0 2 2h18a2 2 0 0 0 2-2V10a2 2 0 0 0-2-2Z\" fill=\"currentColor\"></path><path d=\"M4 18H2V4a2 2 0 0 1 2-2h14v2H4Z\" fill=\"currentColor\"></path></svg></span>\n<span class=\"check\"><svg stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-width=\"3\" stroke=\"currentColor\" fill=\"none\" viewBox=\"0 0 24 24\" height=\"100%\" width=\"100%\" xmlns=\"http://www.w3.org/2000/svg\"><polyline points=\"20 6 9 17 4 12\"></polyline></svg></span>\n</button>function canPartition(nums) {\n   const sum = nums.reduce((a, b) =&gt; a + b, 0);\n   if (sum % 2 !== 0) return false;\n   const halfSum = sum / 2;\n   const map = new Map();\n   for (const num of nums) {\n       if (map.has(num)) return false;\n       map.set(num, true);\n   }\n   const set = new Set();\n   for (const num of nums) {\n       if (set.has(num)) return false;\n       set.add(num);\n   }\n   const dp = new Array(nums.length + 1).fill(false);\n   dp[0] = true;\n   for (let i = 1; i &lt;= nums.length; i++) {\n       for (let j = 0; j &lt; i; j++) {\n           if (dp[j] &amp;&amp; nums[j] &lt;= halfSum - nums[i]) {\n               dp[i] = true;\n               break;\n           }\n       }\n   }\n   return dp[nums.length];\n}\n</code></pre>\n<p>Note that these implementations are just examples and may not be the most efficient or the most readable. The best approach will depend on the specific requirements of the problem and the characteristics of the input data.</p>\n</span>  </div>"
}