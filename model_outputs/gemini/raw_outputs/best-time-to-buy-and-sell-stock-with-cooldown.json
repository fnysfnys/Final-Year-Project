{
    "Java": "## 10 Implementations of maxProfit Function in Java:\n\nHere are 10 different ways to implement the `maxProfit` function in Java:\n\n**1. Dynamic Programming (Bottom-Up):**\n\n```java\npublic int maxProfit(int[] prices) {\n  int n = prices.length;\n  int buy = Integer.MAX_VALUE, sell = 0, cooldown = 0;\n  \n  for (int price : prices) {\n    buy = Math.min(buy, price);\n    cooldown = Math.max(cooldown, sell - price);\n    sell = Math.max(sell, price - buy);\n  }\n  \n  return sell;\n}\n```\n\n**2. Dynamic Programming (Top-Down):**\n\n```java\npublic int maxProfit(int[] prices) {\n  int n = prices.length;\n  int[][] memo = new int[n][3]; // 0: buy, 1: sell, 2: cooldown\n  return helper(prices, 0, 0, memo);\n}\n\nprivate int helper(int[] prices, int i, int state, int[][] memo) {\n  if (i >= prices.length || memo[i][state] != 0) {\n    return memo[i][state];\n  }\n  \n  int buy = Integer.MIN_VALUE, sell = Integer.MIN_VALUE, cooldown = Integer.MIN_VALUE;\n  \n  if (state == 0) {\n    buy = -prices[i];\n    cooldown = helper(prices, i + 1, 2, memo);\n  } else if (state == 1) {\n    sell = prices[i] + helper(prices, i + 1, 0, memo);\n    cooldown = helper(prices, i + 1, 2, memo);\n  } else {\n    sell = prices[i] + helper(prices, i + 2, 0, memo);\n    cooldown = helper(prices, i + 1, 2, memo);\n  }\n  \n  memo[i][state] = Math.max(buy, Math.max(sell, cooldown));\n  return memo[i][state];\n}\n```\n\n**3. State Machine:**\n\n```java\npublic int maxProfit(int[] prices) {\n  enum State {BUY, SELL, COOLDOWN};\n  State state = State.BUY;\n  int buy = Integer.MAX_VALUE, profit = 0;\n  \n  for (int price : prices) {\n    switch (state) {\n      case BUY:\n        buy = Math.min(buy, price);\n        state = State.COOLDOWN;\n        break;\n      case SELL:\n        profit = Math.max(profit, price - buy);\n        buy = Integer.MAX_VALUE;\n        state = State.COOLDOWN;\n        break;\n      case COOLDOWN:\n        if (price < buy) {\n          buy = price;\n          state = State.BUY;\n        } else {\n          state = State.SELL;\n        }\n        break;\n    }\n  }\n  \n  return profit;\n}\n```\n\n**4. Greedy Approach (Not guaranteed optimal):**\n\n```java\npublic int maxProfit(int[] prices) {\n  int profit = 0;\n  for (int i = 1; i < prices.length; i++) {\n    if (prices[i] > prices[i - 1]) {\n      profit += prices[i] - prices[i - 1];\n    }\n  }\n  return profit;\n}\n```\n\n**5. One Pass Array Traversal:**\n\n```java\npublic int maxProfit(int[] prices) {\n  int buy = Integer.MAX_VALUE, sell = 0;\n  \n  for (int price : prices) {\n    buy = Math.min(buy, price);\n    sell = Math.max(sell, price - buy);\n  }\n  \n  return sell;\n}\n```\n\n**6. Recursion (Naive and less efficient):**\n\n```java\npublic int maxProfit(int[] prices) {\n  if (prices.length <= 1) return 0;\n  \n  int max = 0;\n  for (int i = 0; i < prices.length - 1; i++) {\n    int profit = maxProfit(Arrays.copyOfRange(prices, i + 1, prices.length));\n    \n    if (prices[i] < prices[i + 1]) {",
    "Python": "## 10 Implementations of maxProfit function in Python:\n\nHere are 10 different implementations of the `maxProfit` function in Python, each with a slightly different approach:\n\n**1. Dynamic Programming (DP) - Iterative:**\n\n```python\ndef maxProfit(self, prices):\n  n = len(prices)\n  if n < 2: return 0\n  buy, sell, cooldown = float('-inf'), 0, float('-inf')\n  for price in prices:\n    buy = max(buy, cooldown - price)\n    cooldown = sell\n    sell = max(sell, price + buy)\n  return sell\n```\n\n**2. Dynamic Programming (DP) - Recursive:**\n\n```python\ndef maxProfit(self, prices, i, buy, sell, cooldown):\n  if i >= len(prices): return 0\n  if buy != float('-inf') and sell != float('-inf'): return sell\n  profit_buy = self.maxProfit(prices, i+1, buy, min(sell, prices[i]), cooldown)\n  profit_cooldown = self.maxProfit(prices, i+1, float('-inf'), sell, buy)\n  return max(profit_buy, profit_cooldown)\n\ndef maxProfitWrapper(self, prices):\n  return self.maxProfit(prices, 0, float('-inf'), float('-inf'), float('-inf'))\n```\n\n**3. Greedy Approach:**\n\n```python\ndef maxProfit(self, prices):\n  profit = 0\n  buy = prices[0]\n  for price in prices[1:]:\n    if price > buy:\n      profit += price - buy\n      buy = price\n    else:\n      buy = min(buy, price)\n  return profit\n```\n\n**4. State Machine Approach:**\n\n```python\nclass State:\n  def __init__(self, hold, sold):\n    self.hold, self.sold = hold, sold\n\ndef maxProfit(self, prices):\n  states = [State(float('-inf'), 0), State(0, float('-inf'))]\n  for price in prices:\n    states[0] = State(max(states[0].hold, states[1].sold - price), states[0].sold)\n    states[1] = State(max(states[0].hold + price, states[1].sold), max(states[1].sold, states[0].sold))\n  return max(states[0].hold, states[1].sold)\n```\n\n**5. Two Pointers Approach:**\n\n```python\ndef maxProfit(self, prices):\n  n = len(prices)\n  if n < 2: return 0\n  buy, sell = 0, 1\n  profit = 0\n  while sell < n:\n    while buy < sell and prices[buy] >= prices[sell]:\n      sell += 1\n    if buy < sell:\n      profit += prices[sell] - prices[buy]\n      buy = sell + 1\n      while buy < n and prices[buy] <= prices[sell - 1]:\n        buy += 1\n    sell += 1\n  return profit\n```\n\n**6. Rolling Window Approach:**\n\n```python\ndef maxProfit(self, prices):\n  n = len(prices)\n  if n < 2: return 0\n  min_price = max_price = prices[0]\n  profit = 0\n  for i in range(1, n):\n    min_price = min(min_price, prices[i])\n    max_price = max(max_price, prices[i])\n    profit = max(profit, max_price - min_price)\n  return profit\n```\n\n**7. NumPy (if allowed):**\n\n```python\nimport numpy as np\n\ndef maxProfit(self, prices):\n  prices = np.array(prices)\n  min_price = prices.cummin()\n  profit = prices - min_price\n  return profit.max()\n```\n\n**8. Pandas (if allowed):**\n\n```python\nimport pandas as pd\n\ndef maxProfit(self, prices):\n  df = pd.DataFrame({\"price\": prices})\n  df[\"min_price\"] = df[\"price\"].cummin()\n  df[\"profit\"] = df[\"price\"] - df[\"min_price\"]\n  return df[\"profit\"].max()\n```\n\n**9. Recursive Solution with Memoization:**\n\n```python\nmemo = {}\n\ndef maxProfit(self, prices, i, buy, sell):\n  if i >= len(prices",
    "JavaScript": "## 10 Implementations of `maxProfit` function in JavaScript:\n\n**1. Dynamic Programming (with space optimization):**\n\n```javascript\nvar maxProfit = function(prices) {\n  if (prices.length < 2) return 0;\n  \n  const buy = [prices[0], Number.POSITIVE_INFINITY];\n  const sell = [0, 0];\n  \n  for (let i = 1; i < prices.length; i++) {\n    buy[0] = Math.min(buy[0], prices[i] - sell[1]);\n    sell[0] = Math.max(sell[0], prices[i] - buy[1]);\n    buy[1] = buy[0];\n    sell[1] = sell[0];\n  }\n  \n  return Math.max(...sell);\n};\n```\n\n**2. Dynamic Programming (tabulation):**\n\n```javascript\nvar maxProfit = function(prices) {\n  if (prices.length < 2) return 0;\n  \n  const buy = new Array(prices.length).fill(Number.POSITIVE_INFINITY);\n  const sell = new Array(prices.length).fill(0);\n  \n  buy[0] = prices[0];\n  \n  for (let i = 1; i < prices.length; i++) {\n    sell[i] = Math.max(sell[i - 1], prices[i] - buy[i - 1]);\n    buy[i] = Math.min(buy[i - 1], prices[i] - sell[i - 2]);\n  }\n  \n  return Math.max(...sell);\n};\n```\n\n**3. Brute Force (nested loops):**\n\n```javascript\nvar maxProfit = function(prices) {\n  let maxProfit = 0;\n  \n  for (let i = 0; i < prices.length - 1; i++) {\n    for (let j = i + 2; j < prices.length; j++) {\n      const profit = prices[j] - prices[i];\n      maxProfit = Math.max(maxProfit, profit);\n    }\n  }\n  \n  return maxProfit;\n};\n```\n\n**4. Kadane's Algorithm (modifying prices array):**\n\n```javascript\nvar maxProfit = function(prices) {\n  let maxProfit = 0;\n  let minPrice = prices[0];\n  \n  for (let i = 1; i < prices.length; i++) {\n    const profit = prices[i] - minPrice;\n    maxProfit = Math.max(maxProfit, profit);\n    minPrice = Math.min(minPrice, prices[i]);\n  }\n  \n  return maxProfit;\n};\n```\n\n**5. Recursion (with memoization):**\n\n```javascript\nconst memo = {};\n\nvar maxProfit = function(prices, i, canBuy) {\n  const key = `${i}-${canBuy}`;\n  if (key in memo) return memo[key];\n  \n  if (i >= prices.length) return 0;\n  \n  let profit = 0;\n  if (canBuy) {\n    profit = Math.max(maxProfit(prices, i + 1, false) - prices[i], maxProfit(prices, i + 1, true));\n  } else {\n    profit = Math.max(maxProfit(prices, i + 1, true) + prices[i], maxProfit(prices, i + 2, false));\n  }\n  \n  memo[key] = profit;\n  return profit;\n};\n\nmaxProfit = function(prices) {\n  return maxProfit(prices, 0, true);\n};\n```\n\n**6. Stack-based approach (iterative):**\n\n```javascript\nvar maxProfit = function(prices) {\n  const stack = [];\n  let profit = 0;\n  \n  for (const price of prices) {\n    if (stack.length === 0 || price > stack[stack.length - 1]) {\n      stack.push(price);\n    } else if (price < stack[stack.length - 1]) {\n      const minPrice = stack.pop();\n      profit += stack[stack.length - 1] - minPrice;\n    }\n  }\n  \n  return profit;\n};\n```\n\n**7. Queue-based approach (iterative):**\n\n```javascript\nvar maxProfit = function(prices) {\n"
}