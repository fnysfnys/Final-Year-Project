{
    "Java": "Here are 10 different possible implementations of the `numDistinct` function in Java:\n\n**1. Dynamic Programming (Bottom-Up):**\n\n```java\npublic int numDistinct(String s, String t) {\n    int m = s.length(), n = t.length();\n    int[][] dp = new int[m + 1][n + 1];\n\n    for (int i = 0; i <= m; i++) {\n        dp[i][0] = 1; // base case: empty string t\n    }\n\n    for (int i = 1; i <= m; i++) {\n        for (int j = 1; j <= n; j++) {\n            dp[i][j] = dp[i - 1][j]; // exclude current char in s\n            if (s.charAt(i - 1) == t.charAt(j - 1)) {\n                dp[i][j] += dp[i - 1][j - 1]; // include current char in s\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n```\n\n**2. Dynamic Programming (Top-Down):**\n\n```java\npublic int numDistinct(String s, String t) {\n    int m = s.length(), n = t.length();\n    int[][] memo = new int[m + 1][n + 1];\n\n    return helper(s, t, m, n, memo);\n}\n\nprivate int helper(String s, String t, int i, int j, int[][] memo) {\n    if (j == 0) {\n        return 1; // base case: empty string t\n    }\n    if (i == 0) {\n        return 0; // base case: empty string s\n    }\n    if (memo[i][j] != 0) {\n        return memo[i][j];\n    }\n\n    int res = 0;\n    if (s.charAt(i - 1) == t.charAt(j - 1)) {\n        res += helper(s, t, i - 1, j - 1, memo); // include current char in s\n    }\n    res += helper(s, t, i - 1, j, memo); // exclude current char in s\n\n    memo[i][j] = res;\n    return res;\n}\n```\n\n**3. Recursion with Memoization:**\n\n```java\npublic int numDistinct(String s, String t) {\n    int m = s.length(), n = t.length();\n    int[][] memo = new int[m + 1][n + 1];\n\n    return helper(s, t, 0, 0, memo);\n}\n\nprivate int helper(String s, String t, int i, int j, int[][] memo) {\n    if (j == t.length()) {\n        return 1; // base case: found entire t in s\n    }\n    if (i == s.length()) {\n        return 0; // base case: no more chars in s\n    }\n    if (memo[i][j] != 0) {\n        return memo[i][j];\n    }\n\n    int res = 0;\n    if (s.charAt(i) == t.charAt(j)) {\n        res += helper(s, t, i + 1, j + 1, memo); // include current char in s\n    }\n    res += helper(s, t, i + 1, j, memo); // exclude current char in s\n\n    memo[i][j] = res;\n    return res;\n}\n```\n\n**4. Bitwise Rolling Hash:**\n\n```java\npublic int numDistinct(String s, String t) {\n    int m = s.length(), n = t.length();\n    int prime = 101;\n    int base = 31;\n    int tHash = 0;\n    for (int i = 0; i < n; i++) {\n        tHash = (tHash * base + t.charAt(i) - 'a') % prime;\n    }\n\n    int[] sHashes = new int[m - n + 1];\n    int currHash = 0;\n    for (int i = 0; i < n; i++) {\n        currHash = (currHash * base + s.charAt(i) - 'a') % prime;\n    }\n    sHashes[0] = currHash;\n\n    for (int",
    "Python": "Here are 10 different possible implementations of the `numDistinct` function in Python:\n\n**1. Dynamic Programming (Bottom-Up):**\n\n```python\ndef numDistinct(self, s, t):\n    m, n = len(s), len(t)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    for i in range(m + 1):\n        dp[i][0] = 1  # Empty string matches empty subsequences\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            dp[i][j] = dp[i - 1][j] + (dp[i - 1][j - 1] if s[i - 1] == t[j - 1] else 0)\n    return dp[m][n]\n```\n\n**2. Dynamic Programming (Top-Down) with Memoization:**\n\n```python\ndef numDistinct(self, s, t):\n    dp = {}\n\n    def helper(i, j):\n        if (i, j) in dp:\n            return dp[(i, j)]\n        if j == 0:\n            return 1\n        if i == 0:\n            return 0\n        dp[(i, j)] = helper(i - 1, j) + (helper(i - 1, j - 1) if s[i - 1] == t[j - 1] else 0)\n        return dp[(i, j)]\n\n    return helper(len(s), len(t))\n```\n\n**3. Backtracking (Recursion):**\n\n```python\ndef numDistinct(self, s, t):\n    def helper(i, j, remaining):\n        if not remaining:\n            return 1\n        if i == len(s) or j == len(t):\n            return 0\n        return helper(i + 1, j, remaining) + (helper(i + 1, j + 1, remaining - 1) if s[i] == t[j] else 0)\n\n    return helper(0, 0, len(t))\n```\n\n**4. Two-Pointer Approach:**\n\n```python\ndef numDistinct(self, s, t):\n    i, j, count = 0, 0, 0\n    while i < len(s):\n        if s[i] == t[j]:\n            count += (i - j) if j else 1\n            j += 1\n        i += 1\n    return count\n```\n\n**5. Rolling Hash and Suffix Array:**\n\n```python\ndef numDistinct(self, s, t):\n    def get_hash(string):\n        p = 31\n        mod = 10**9 + 7\n        hash_value = 0\n        for char in string:\n            hash_value = (hash_value * p + ord(char)) % mod\n        return hash_value\n\n    hash_t = get_hash(t)\n    n, m = len(s), len(t)\n    suffix_array = sorted(range(n), key=lambda i: s[i:])\n    count = 0\n    power = 1\n    for i in range(1, m + 1):\n        power *= p\n    p_pow = 1\n    for i in suffix_array:\n        if i + m > n:\n            break\n        current_hash = (get_hash(s[i:i + m]) - p_pow * s[i]) % mod\n        if current_hash == hash_t:\n            count += 1\n        p_pow = (p_pow * ord(s[i])) % mod\n    return count\n```\n\n**6. Bitmask DP:**\n\n```python\ndef numDistinct(self, s, t):\n    m, n = len(s), len(t)\n    dp = [[0] * (1 << n) for _ in range(m + 1)]\n    for i in range(m + 1):\n        dp[i][0] = 1\n    for i in range(1, m + 1):\n        for mask in range(1 << n):\n            for j in range(n):\n                if s[i - 1] == t[j] and (mask & (1 << j)) == 0:\n                    dp[i][mask] += dp[i - 1][mask",
    "JavaScript": "## 10 Implementations of the `numDistinct` function in JavaScript:\n\n**1. Dynamic Programming:**\n\nThis version iterates through both strings, building a 2D table to store the number of distinct subsequences ending at each index.\n\n```javascript\nvar numDistinct = function(s, t) {\n  const m = s.length, n = t.length;\n  const dp = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0));\n  \n  for (let i = 0; i <= m; i++) {\n    dp[i][0] = 1; // Empty subsequence matches empty string\n  }\n  \n  for (let i = 1; i <= m; i++) {\n    for (let j = 1; j <= n; j++) {\n      dp[i][j] = dp[i - 1][j]; // Skip current char in s\n      if (s[i - 1] === t[j - 1]) {\n        dp[i][j] += dp[i - 1][j - 1]; // Include current char if matches\n      }\n    }\n  }\n  \n  return dp[m][n];\n};\n```\n\n**2. Recursive with Memoization:**\n\nThis version uses memoization to avoid redundant calculations.\n\n```javascript\nconst memo = {};\n\nvar numDistinct = function(s, t, i = 0, j = 0) {\n  const key = i + \";\" + j;\n  if (memo[key]) return memo[key];\n  \n  if (j === t.length) return 1; // Base case: t matched\n  if (i === s.length) return 0; // Base case: s exhausted\n  \n  const ans = numDistinct(s, t, i + 1, j) + (s[i] === t[j] ? numDistinct(s, t, i + 1, j + 1) : 0);\n  memo[key] = ans;\n  return ans;\n};\n```\n\n**3. Two-Pointer:**\n\nThis method uses two pointers to iterate through both strings while maintaining a counter for distinct subsequences.\n\n```javascript\nvar numDistinct = function(s, t) {\n  let ans = 0;\n  let i = 0, j = 0;\n  \n  while (i < s.length) {\n    if (s[i] === t[j]) {\n      j++;\n      if (j === t.length) {\n        ans++;\n        j = 0;\n      }\n    }\n    i++;\n  }\n  \n  return ans;\n};\n```\n\n**4. Rolling Hash:**\n\nThis version uses a rolling hash to compare substrings efficiently.\n\n```javascript\nconst prime = 113;\n\nvar numDistinct = function(s, t) {\n  const m = s.length, n = t.length;\n  const sHash = rollingHash(s, n);\n  const tHash = rollingHash(t);\n  let ans = 0;\n  \n  for (let i = 0; i < m - n + 1; i++) {\n    const subHash = rollingHash(s.slice(i, i + n));\n    if (sHash === subHash && checkEqual(s.slice(i, i + n), t)) {\n      ans++;\n    }\n  }\n  \n  return ans;\n};\n\nfunction rollingHash(str, len) {\n  let hash = 0;\n  for (let i = 0; i < len; i++) {\n    hash = (hash * prime + str.charCodeAt(i)) % MOD;\n  }\n  return hash;\n}\n\nfunction checkEqual(str1, str2) {\n  for (let i = 0; i < str1.length; i++) {\n    if (str1[i] !== str2[i]) return false;\n  }\n  return true;\n}\n```\n\n**5. Trie-based:**\n\nThis approach builds a Trie from `t` and performs efficient search in `s` for matching subsequences.\n\n```javascript\nclass TrieNode {\n  constructor() {\n    this.children = new Array(26).fill(null);\n    this.isEnd = false;\n  }\n}\n\nvar numDistinct = function(s, t) {\n  const root = new TrieNode();\n  for (const char of t) {\n    let"
}