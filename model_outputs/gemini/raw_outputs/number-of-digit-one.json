{
    "Java": "## 10 Implementations of countDigitOne function in Java:\n\nHere are 10 different implementations of the `countDigitOne` function in Java:\n\n**1. Iterative with string conversion:**\n\n```java\npublic int countDigitOne(int n) {\n  int count = 0;\n  for (int i = 1; i <= n; i++) {\n    count += String.valueOf(i).chars().filter(c -> c == '1').count();\n  }\n  return count;\n}\n```\n\n**2. Iterative with modulo and division:**\n\n```java\npublic int countDigitOne(int n) {\n  int count = 0;\n  for (int i = 1; i <= n; i++) {\n    int current = i;\n    while (current != 0) {\n      if (current % 10 == 1) {\n        count++;\n      }\n      current /= 10;\n    }\n  }\n  return count;\n}\n```\n\n**3. Recursive with modulo and division:**\n\n```java\npublic int countDigitOne(int n) {\n  if (n == 0) {\n    return 0;\n  }\n  int lastDigit = n % 10;\n  int prevCount = countDigitOne(n / 10);\n  if (lastDigit == 0) {\n    return prevCount;\n  } else if (lastDigit == 1) {\n    return prevCount + n % 10 + 1;\n  } else {\n    return prevCount + 10 * prevCount + 10;\n  }\n}\n```\n\n**4. Dynamic Programming:**\n\n```java\npublic int countDigitOne(int n) {\n  int[] dp = new int[n + 1];\n  dp[0] = 0;\n  for (int i = 1; i <= n; i++) {\n    int firstDigit = i / 10;\n    int lastDigit = i % 10;\n    dp[i] = dp[firstDigit] * 10 + (lastDigit == 0 ? 0 : (lastDigit == 1 ? firstDigit + 1 : firstDigit * 10 + 10));\n  }\n  return dp[n];\n}\n```\n\n**5. Mathematical formula:**\n\n```java\npublic int countDigitOne(int n) {\n  int ones = 0;\n  for (int i = 1; i <= 9; i++) {\n    ones += (n / i + 1) * i;\n  }\n  ones -= (n / 10 + 1) * 9;\n  return ones;\n}\n```\n\n**6. Bit manipulation:**\n\n```java\npublic int countDigitOne(int n) {\n  int count = 0;\n  while (n != 0) {\n    n &= n - 1;\n    count++;\n  }\n  return count;\n}\n```\n\n**7. Stream API:**\n\n```java\npublic int countDigitOne(int n) {\n  return IntStream.rangeClosed(1, n)\n      .boxed()\n      .mapToInt(String::valueOf)\n      .flatMapToInt(s -> s.chars().filter(c -> c == '1'))\n      .count();\n}\n```\n\n**8. Regular expressions:**\n\n```java\npublic int countDigitOne(int n) {\n  int count = 0;\n  for (int i = 1; i <= n; i++) {\n    count += String.valueOf(i).matches(\".*1.*\") ? 1 : 0;\n  }\n  return count;\n}\n```\n\n**9. Guava library (if available):**\n\n```java\npublic int countDigitOne(int n) {\n  int count = 0;\n  for (int i = 1; i <= n; i++) {\n    count += Ints.asList(String.valueOf(i).split(\"\")).contains(1) ? 1 : 0;\n  }\n  return count;\n}\n```\n\n**10. Apache Commons Lang library (if available):**\n\n```java\npublic int countDigitOne(int n) {\n  int count = 0;\n  for (int i = 1; i <= n; i++) {\n    count += StringUtils.countMatches(String.valueOf(i), \"1\");\n  }\n  return count;\n}\n```\n\nThese are just some examples, and the",
    "Python": "Here are 10 different Python implementations of the `countDigitOne` function:\n\n**1. Recursive approach:**\n\n```python\ndef countDigitOne(n):\n  if n == 0:\n    return 0\n  \n  res = n % 10 * countDigitOne(n // 10)\n  if n % 10 == 1:\n    res += n // 10 + 1\n  return res\n```\n\n**2. Iterative approach with string conversion:**\n\n```python\ndef countDigitOne(n):\n  count = 0\n  for i in range(1, n + 1):\n    count += str(i).count(\"1\")\n  return count\n```\n\n**3. Iterative approach with digit manipulation:**\n\n```python\ndef countDigitOne(n):\n  count = 0\n  power = 1\n  while n > 0:\n    digit = n % 10\n    prev_count = n // 10 * power\n    if digit == 1:\n      count += prev_count + 1\n    elif digit > 1:\n      count += prev_count + power\n    power *= 10\n    n //= 10\n  return count\n```\n\n**4. Mathematical formula based on number decomposition:**\n\n```python\ndef countDigitOne(n):\n  count = 0\n  for d in range(1, 10):\n    base = 10 ** (len(str(n)) - 1)\n    while base > 0:\n      prev_count = (n // base) * d\n      if n % base >= base // 10 + 1:\n        prev_count += base // 10 + 1 - (n % base)\n      elif n % base == base // 10:\n        prev_count += (n // base) + 1\n      count += prev_count\n      base //= 10\n  return count\n```\n\n**5. Dynamic programming approach:**\n\n```python\ndef countDigitOne(n):\n  dp = [0] * (n + 1)\n  for i in range(1, n + 1):\n    dp[i] = (dp[i // 10] + (i % 10 == 1)) * 10 + (i % 10 > 1)\n  return dp[n]\n```\n\n**6. Using built-in `bin` function:**\n\n```python\ndef countDigitOne(n):\n  count = 0\n  while n > 0:\n    count += bin(n).count(\"1\")\n    n //= 2\n  return count\n```\n\n**7. Using regular expressions:**\n\n```python\nimport re\n\ndef countDigitOne(n):\n  count = 0\n  for i in range(1, n + 1):\n    count += len(re.findall(\"1\", str(i)))\n  return count\n```\n\n**8. Using list comprehension and sum:**\n\n```python\ndef countDigitOne(n):\n  return sum(str(i).count(\"1\") for i in range(1, n + 1))\n```\n\n**9. Using lambda function and map:**\n\n```python\ndef countDigitOne(n):\n  return sum(map(lambda i: str(i).count(\"1\"), range(1, n + 1)))\n```\n\n**10. Using dictionary-based approach:**\n\n```python\ndef countDigitOne(n):\n  dp = {0: 0, 1: 1}\n  for i in range(2, 10):\n    prev_count = i // 10 * dp[i // 10] + (i % 10 == 1)\n    if i % 10 > 1:\n      prev_count += i // 10 + 1\n    dp[i] = prev_count\n  return sum(dp[d] * 10**pow for d, pow in enumerate(str(n)[::-1]))\n```\n\nThese implementations offer different approaches with varying levels of efficiency and readability. Choose the one that best suits your needs and programming style.\n",
    "JavaScript": "## 10 Implementations of the countDigitOne function in JavaScript:\n\nHere are 10 different ways to implement the `countDigitOne` function in JavaScript:\n\n**1. Iterative approach:**\n\n```javascript\nvar countDigitOne = function(n) {\n  let count = 0;\n  for (let i = 0; i <= n; i++) {\n    count += String(i).split('').filter(ch => ch === '1').length;\n  }\n  return count;\n};\n```\n\n**2. Recursive approach:**\n\n```javascript\nvar countDigitOne = function(n) {\n  if (n < 0) return 0;\n  if (n < 10) return n === 1;\n  let base = Math.pow(10, Math.floor(Math.log10(n)));\n  let prefix = Math.floor(n / base);\n  let remainder = n % base;\n  return prefix * countDigitOne(base - 1) + (prefix === 1 ? n - base + 1 : base) + countDigitOne(remainder);\n};\n```\n\n**3. Mathematical approach:**\n\n```javascript\nvar countDigitOne = function(n) {\n  if (n < 0) return 0;\n  let digits = Math.floor(Math.log10(n) + 1);\n  let sum = 0;\n  for (let i = 1; i <= digits; i++) {\n    let factor = Math.pow(10, i - 1);\n    sum += (Math.floor(n / factor) % 10 * factor + Math.min(Math.max(n - Math.floor(n / factor) * factor + 1, 0), factor));\n  }\n  return sum;\n};\n```\n\n**4. One-liner using Array.from():**\n\n```javascript\nvar countDigitOne = n => Math.max(0, ...Array.from(String(n + 1)).map(Number)) * (n + 1);\n```\n\n**5. One-liner using reduce():**\n\n```javascript\nvar countDigitOne = n => [...String(n + 1)].reduce((acc, c) => acc + Number(c), 0) * (n + 1);\n```\n\n**6. Using String split() and indexOf():**\n\n```javascript\nvar countDigitOne = n => {\n  let count = 0;\n  for (let i = 0; i <= n; i++) {\n    count += String(i).split('1').length - 1;\n  }\n  return count;\n};\n```\n\n**7. Using regular expressions:**\n\n```javascript\nvar countDigitOne = n => [...String(n + 1)].filter(c => c === '1').length * (n + 1);\n```\n\n**8. Using Math.floor() and bit manipulation:**\n\n```javascript\nvar countDigitOne = n => {\n  let count = 0;\n  while (n > 0) {\n    count += n % 10 === 1 && Math.floor(n / 10) % 2 === 0;\n    n = Math.floor(n / 10);\n  }\n  return count;\n};\n```\n\n**9. Using lookup table:**\n\n```javascript\nconst lookup = [0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19];\nvar countDigitOne = n => {\n  let sum = 0;\n  while (n > 0) {\n    sum += lookup[n % 10];\n    n = Math.floor(n / 10);\n  }\n  return sum;\n};\n```\n\n**10. Using dynamic programming:**\n\n```javascript\nconst dp = Array(101).fill(0);\ndp[0] = 0;\ndp[1] = 1;\nfor (let i = 2; i <= 100; i++) {\n  const d = Math.floor(Math.log10(i));\n  dp[i] = d * dp[Math.pow(10, d)] + (dp[i - Math.pow(10, d)] + (i % Math.pow(10, d"
}