{
    "Java": "## 10 Implementations of nthUglyNumber Function:\n\nHere are 10 different implementations of the `nthUglyNumber` function with varying approaches and trade-offs:\n\n**1. Brute Force:**\nIteratively generate numbers and check if they are ugly. Time complexity: O(n^2), Space complexity: O(1).\n\n```java\npublic int nthUglyNumber(int n) {\n  int count = 0, num = 1;\n  while (count < n) {\n    if (isUgly(num)) {\n      count++;\n    }\n    num++;\n  }\n  return num - 1;\n}\n\nboolean isUgly(int num) {\n  while (num % 2 == 0) {\n    num /= 2;\n  }\n  while (num % 3 == 0) {\n    num /= 3;\n  }\n  while (num % 5 == 0) {\n    num /= 5;\n  }\n  return num == 1;\n}\n```\n\n**2. Optimized Sieve:**\nSimilar to brute force, but stores and checks previously found ugly numbers for efficiency. Time complexity: O(n log log n), Space complexity: O(n).\n\n```java\npublic int nthUglyNumber(int n) {\n  int[] dp = new int[n + 1];\n  dp[1] = 1;\n  int i2 = 1, i3 = 1, i5 = 1;\n  for (int i = 2; i <= n; i++) {\n    int next2 = dp[i2] * 2;\n    int next3 = dp[i3] * 3;\n    int next5 = dp[i5] * 5;\n    dp[i] = Math.min(Math.min(next2, next3), next5);\n    if (dp[i] == next2) {\n      i2++;\n    }\n    if (dp[i] == next3) {\n      i3++;\n    }\n    if (dp[i] == next5) {\n      i5++;\n    }\n  }\n  return dp[n];\n}\n```\n\n**3. Priority Queue:**\nUses a priority queue to efficiently find the next ugly number. Time complexity: O(n log n), Space complexity: O(log n).\n\n```java\npublic int nthUglyNumber(int n) {\n  PriorityQueue<Integer> pq = new PriorityQueue<>();\n  pq.offer(1);\n  Set<Integer> seen = new HashSet<>();\n  for (int i = 0; i < n - 1; i++) {\n    int num = pq.poll();\n    if (!seen.contains(num * 2)) {\n      pq.offer(num * 2);\n      seen.add(num * 2);\n    }\n    if (!seen.contains(num * 3)) {\n      pq.offer(num * 3);\n      seen.add(num * 3);\n    }\n    if (!seen.contains(num * 5)) {\n      pq.offer(num * 5);\n      seen.add(num * 5);\n    }\n  }\n  return pq.poll();\n}\n```\n\n**4. Heap + Dynamic Programming:**\nCombines heap and dynamic programming for faster lookups. Time complexity: O(n log log n), Space complexity: O(n).\n\n```java\npublic int nthUglyNumber(int n) {\n  int[] dp = new int[n + 1];\n  PriorityQueue<Integer> pq = new PriorityQueue<>();\n  dp[1] = 1;\n  pq.offer(1);\n  for (int i = 2; i <= n; i++) {\n    int num = pq.poll();\n    while (pq.peek() == num) {\n      pq.poll();\n    }\n    dp[i] = num;\n    for (int factor : new int[]{2, 3, 5}) {\n      if (dp[i] > num * factor || dp[dp[i] / factor] != num) {\n        pq.offer(num * factor);\n      }\n    }\n  }\n  return dp[n];\n}\n```\n\n**5. DP based on Math Properties:**\nUtilizes number theory properties to optimize calculations. Time complexity: O(n), Space complexity: O(n).\n\n```java\npublic int nthUglyNumber(int n) {\n  int[] dp = new int[n + 1];",
    "Python": "## 10 Implementations of nthUglyNumber function:\n\n**1. Brute Force:**\n\n```python\ndef nthUglyNumber(self, n):\n    count = 0\n    num = 1\n    while count < n:\n        if self.isUgly(num):\n            count += 1\n        num += 1\n    return num\n```\n\n**2. Dynamic Programming (Naive):**\n\n```python\ndef nthUglyNumber(self, n):\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    i2, i3, i5 = 1, 1, 1\n    for j in range(2, n + 1):\n        next2, next3, next5 = 2 * dp[i2], 3 * dp[i3], 5 * dp[i5]\n        min_val = min(next2, next3, next5)\n        dp[j] = min_val\n        if min_val == next2:\n            i2 += 1\n        elif min_val == next3:\n            i3 += 1\n        else:\n            i5 += 1\n    return dp[n]\n```\n\n**3. Dynamic Programming (Efficient):**\n\n```python\ndef nthUglyNumber(self, n):\n    dp = [0] * (n + 1)\n    dp[1] = 1\n    i2, i3, i5 = 1, 1, 1\n    for j in range(2, n + 1):\n        dp[j] = min(dp[i2] * 2, dp[i3] * 3, dp[i5] * 5)\n        if dp[j] == dp[i2] * 2:\n            i2 += 1\n        if dp[j] == dp[i3] * 3:\n            i3 += 1\n        if dp[j] == dp[i5] * 5:\n            i5 += 1\n    return dp[n]\n```\n\n**4. Heap (Min-Heap):**\n\n```python\nimport heapq\n\ndef nthUglyNumber(self, n):\n    heap = [1]\n    seen = set()\n    for _ in range(n - 1):\n        num = heapq.heappop(heap)\n        for prime in [2, 3, 5]:\n            new_num = num * prime\n            if new_num not in seen:\n                heapq.heappush(heap, new_num)\n                seen.add(new_num)\n    return heap[0]\n```\n\n**5. Sieve of Eratosthenes:**\n\n```python\ndef nthUglyNumber(self, n):\n    primes = [False] * (1691)\n    primes[0] = primes[1] = True\n    for i in range(2, int(1691**0.5) + 1):\n        if not primes[i]:\n            for j in range(i * i, 1691, i):\n                primes[j] = True\n    ugly_nums = [1]\n    i2, i3, i5 = 0, 0, 0\n    while len(ugly_nums) < n:\n        next2, next3, next5 = ugly_nums[i2] * 2, ugly_nums[i3] * 3, ugly_nums[i5] * 5\n        min_val = min(next2, next3, next5)\n        if min_val == next2 and not primes[next2 // 2]:\n            i2 += 1\n        elif min_val == next3 and not primes[next3 // 3]:\n            i3 += 1\n        else:\n            i5 += 1\n        ugly_nums.append(min_val)\n    return ugly_nums[n - 1]\n```\n\n**6. Mathematical Approach:**\n\n```python\ndef nthUglyNumber(self, n):\n    count_2, count_3, count_5 = 0, 0, 0\n    while n > 0:\n        next_2, next_3, next_5 = 2 ** (count_2 + 1), 3 ** (count_3 + 1), 5 ** (count_5 + 1)\n        min_val = min(next_2, next_3, next_5)\n        if min_val == next",
    "JavaScript": "## 10 Implementations of nthUglyNumber Function:\n\nHere are 10 different ways to implement the `nthUglyNumber` function:\n\n**1. Brute Force:**\nThis approach checks every positive integer until it finds the `n`th ugly number. While simple, it's inefficient for large `n`.\n\n```javascript\nvar nthUglyNumber = function(n) {\n  let count = 0, num = 1;\n  while (count < n) {\n    if (isUgly(num)) count++;\n    num++;\n  }\n  return num - 1;\n};\n\nfunction isUgly(num) {\n  while (num % 2 === 0) num /= 2;\n  while (num % 3 === 0) num /= 3;\n  while (num % 5 === 0) num /= 5;\n  return num === 1;\n}\n```\n\n**2. Optimized Check:**\nThis approach performs the same ugly number check as the brute force but stops dividing by a factor once it no longer divides the number.\n\n```javascript\nvar nthUglyNumber = function(n) {\n  let count = 0, num = 1;\n  while (count < n) {\n    if (num % 2 === 0) num /= 2;\n    else if (num % 3 === 0) num /= 3;\n    else if (num % 5 === 0) num /= 5;\n    else count++;\n    num++;\n  }\n  return num - 1;\n};\n```\n\n**3. Dynamic Programming (Optimized):**\nThis approach builds an array of ugly numbers incrementally, considering multiples of the previous found ugly numbers.\n\n```javascript\nvar nthUglyNumber = function(n) {\n  const dp = new Array(n + 1).fill(0);\n  dp[1] = 1;\n  let i2 = i3 = i5 = 1;\n  for (let i = 2; i <= n; i++) {\n    dp[i] = Math.min(dp[i2] * 2, Math.min(dp[i3] * 3, dp[i5] * 5));\n    if (dp[i] === dp[i2] * 2) i2++;\n    if (dp[i] === dp[i3] * 3) i3++;\n    if (dp[i] === dp[i5] * 5) i5++;\n  }\n  return dp[n];\n};\n```\n\n**4. Heap-based Priority Queue:**\nThis approach uses a priority queue to efficiently select the next candidate for an ugly number, prioritizing lower values.\n\n```javascript\nvar nthUglyNumber = function(n) {\n  const queue = new MinPriorityQueue();\n  queue.enqueue(1);\n  const seen = new Set();\n  for (let i = 1; i < n; i++) {\n    const num = queue.dequeue();\n    if (!seen.has(num * 2)) {\n      queue.enqueue(num * 2);\n      seen.add(num * 2);\n    }\n    if (!seen.has(num * 3)) {\n      queue.enqueue(num * 3);\n      seen.add(num * 3);\n    }\n    if (!seen.has(num * 5)) {\n      queue.enqueue(num * 5);\n      seen.add(num * 5);\n    }\n  }\n  return queue.dequeue();\n};\n```\n\n**5. Sieve of Eratosthenes:**\nThis approach finds all ugly numbers within a certain limit using a sieve to mark multiples of 2, 3, and 5, stopping early if enough are found.\n\n```javascript\nvar nthUglyNumber = function(n) {\n  const limit = Math.pow(5, Math.floor(Math.log(n) / Math.log(5)));\n  const sieve = new Array(limit + 1).fill(true);\n  sieve[0] = sieve[1] = false;\n  for (let i = 2; i * i <= limit; i++) {\n    if (sieve[i]) {\n      for (let j = i * i; j <= limit; j += i) {\n        sieve[j] = false;\n      }\n    }\n  }\n  let count = 0, num = 1;\n  while (count < n) {\n    if (sieve[num]) count++;\n    num++;\n  }"
}