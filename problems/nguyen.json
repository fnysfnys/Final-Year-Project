{
    "two-sum": {
        "Java": "class Solution {\n    /**\n     * Given an array of integers nums\u00a0and an integer target, return indices of the two numbers such that they add up to target.\n     * You may assume that each input would have exactly one solution, and you may not use the same element twice.\n     * You can return the answer in any order.\n     * \u00a0\n     * Example 1:\n     * \n     * Input: nums = [2,7,11,15], target = 9\n     * Output: [0,1]\n     * Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n     * \n     * Example 2:\n     * \n     * Input: nums = [3,2,4], target = 6\n     * Output: [1,2]\n     * \n     * Example 3:\n     * \n     * Input: nums = [3,3], target = 6\n     * Output: [0,1]\n     * \n     * \u00a0\n     * Constraints:\n     * \n     * 2 <= nums.length <= 104\n     * -109 <= nums[i] <= 109\n     * -109 <= target <= 109\n     * Only one valid answer exists.\n     * \n     */\n    \n    public int[] twoSum(int[] nums, int target) {\n        \n    }\n}",
        "Python": "class Solution(object):\n    def twoSum(self, nums, target):\n        \"\"\"\n        Given an array of integers nums\u00a0and an integer target, return indices of the two numbers such that they add up to target.\n        You may assume that each input would have exactly one solution, and you may not use the same element twice.\n        You can return the answer in any order.\n        \u00a0\n        Example 1:\n        \n        Input: nums = [2,7,11,15], target = 9\n        Output: [0,1]\n        Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n        \n        Example 2:\n        \n        Input: nums = [3,2,4], target = 6\n        Output: [1,2]\n        \n        Example 3:\n        \n        Input: nums = [3,3], target = 6\n        Output: [0,1]\n        \n        \u00a0\n        Constraints:\n        \n        2 <= nums.length <= 104\n        -109 <= nums[i] <= 109\n        -109 <= target <= 109\n        Only one valid answer exists.\n        \n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        ",
        "JavaScript": "/**\n * Given an array of integers nums\u00a0and an integer target, return indices of the two numbers such that they add up to target.\n * You may assume that each input would have exactly one solution, and you may not use the same element twice.\n * You can return the answer in any order.\n * \u00a0\n * Example 1:\n * \n * Input: nums = [2,7,11,15], target = 9\n * Output: [0,1]\n * Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n * \n * Example 2:\n * \n * Input: nums = [3,2,4], target = 6\n * Output: [1,2]\n * \n * Example 3:\n * \n * Input: nums = [3,3], target = 6\n * Output: [0,1]\n * \n * \u00a0\n * Constraints:\n * \n * 2 <= nums.length <= 104\n * -109 <= nums[i] <= 109\n * -109 <= target <= 109\n * Only one valid answer exists.\n * \n * @param {number[]} nums\n * @param {number} target\n * @return {number[]}\n */\nvar twoSum = function(nums, target) {\n    \n};"
    },
    "pascals-triangle": {
        "Java": "class Solution {\n    /**\n     * Given an integer numRows, return the first numRows of Pascal's triangle.\n     * In Pascal's triangle, each number is the sum of the two numbers directly above it as shown:\n     * \n     * \u00a0\n     * Example 1:\n     * Input: numRows = 5\n     * Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n     * Example 2:\n     * Input: numRows = 1\n     * Output: [[1]]\n     * \n     * \u00a0\n     * Constraints:\n     * \n     * 1 <= numRows <= 30\n     * \n     */\n    \n    public List<List<Integer>> generate(int numRows) {\n        \n    }\n}",
        "Python": "class Solution(object):\n    def generate(self, numRows):\n        \"\"\"\n        Given an integer numRows, return the first numRows of Pascal's triangle.\n        In Pascal's triangle, each number is the sum of the two numbers directly above it as shown:\n        \n        \u00a0\n        Example 1:\n        Input: numRows = 5\n        Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n        Example 2:\n        Input: numRows = 1\n        Output: [[1]]\n        \n        \u00a0\n        Constraints:\n        \n        1 <= numRows <= 30\n        \n        :type numRows: int\n        :rtype: List[List[int]]\n        \"\"\"\n        ",
        "JavaScript": "/**\n * Given an integer numRows, return the first numRows of Pascal's triangle.\n * In Pascal's triangle, each number is the sum of the two numbers directly above it as shown:\n * \n * \u00a0\n * Example 1:\n * Input: numRows = 5\n * Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n * Example 2:\n * Input: numRows = 1\n * Output: [[1]]\n * \n * \u00a0\n * Constraints:\n * \n * 1 <= numRows <= 30\n * \n * @param {number} numRows\n * @return {number[][]}\n */\nvar generate = function(numRows) {\n    \n};"
    },
    "pascals-triangle-ii": {
        "Java": "class Solution {\n    /**\n     * Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal's triangle.\n     * In Pascal's triangle, each number is the sum of the two numbers directly above it as shown:\n     * \n     * \u00a0\n     * Example 1:\n     * Input: rowIndex = 3\n     * Output: [1,3,3,1]\n     * Example 2:\n     * Input: rowIndex = 0\n     * Output: [1]\n     * Example 3:\n     * Input: rowIndex = 1\n     * Output: [1,1]\n     * \n     * \u00a0\n     * Constraints:\n     * \n     * 0 <= rowIndex <= 33\n     * \n     * \u00a0\n     * Follow up: Could you optimize your algorithm to use only O(rowIndex) extra space?\n     * \n     */\n    \n    public List<Integer> getRow(int rowIndex) {\n        \n    }\n}",
        "Python": "class Solution(object):\n    def getRow(self, rowIndex):\n        \"\"\"\n        Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal's triangle.\n        In Pascal's triangle, each number is the sum of the two numbers directly above it as shown:\n        \n        \u00a0\n        Example 1:\n        Input: rowIndex = 3\n        Output: [1,3,3,1]\n        Example 2:\n        Input: rowIndex = 0\n        Output: [1]\n        Example 3:\n        Input: rowIndex = 1\n        Output: [1,1]\n        \n        \u00a0\n        Constraints:\n        \n        0 <= rowIndex <= 33\n        \n        \u00a0\n        Follow up: Could you optimize your algorithm to use only O(rowIndex) extra space?\n        \n        :type rowIndex: int\n        :rtype: List[int]\n        \"\"\"\n        ",
        "JavaScript": "/**\n * Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal's triangle.\n * In Pascal's triangle, each number is the sum of the two numbers directly above it as shown:\n * \n * \u00a0\n * Example 1:\n * Input: rowIndex = 3\n * Output: [1,3,3,1]\n * Example 2:\n * Input: rowIndex = 0\n * Output: [1]\n * Example 3:\n * Input: rowIndex = 1\n * Output: [1,1]\n * \n * \u00a0\n * Constraints:\n * \n * 0 <= rowIndex <= 33\n * \n * \u00a0\n * Follow up: Could you optimize your algorithm to use only O(rowIndex) extra space?\n * \n * @param {number} rowIndex\n * @return {number[]}\n */\nvar getRow = function(rowIndex) {\n    \n};"
    },
    "counting-bits": {
        "Java": "class Solution {\n    /**\n     * Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] is the number of 1's in the binary representation of i.\n     * \u00a0\n     * Example 1:\n     * \n     * Input: n = 2\n     * Output: [0,1,1]\n     * Explanation:\n     * 0 --> 0\n     * 1 --> 1\n     * 2 --> 10\n     * \n     * Example 2:\n     * \n     * Input: n = 5\n     * Output: [0,1,1,2,1,2]\n     * Explanation:\n     * 0 --> 0\n     * 1 --> 1\n     * 2 --> 10\n     * 3 --> 11\n     * 4 --> 100\n     * 5 --> 101\n     * \n     * \u00a0\n     * Constraints:\n     * \n     * 0 <= n <= 105\n     * \n     * \u00a0\n     * Follow up:\n     * \n     * It is very easy to come up with a solution with a runtime of O(n log n). Can you do it in linear time O(n) and possibly in a single pass?\n     * Can you do it without using any built-in function (i.e., like __builtin_popcount in C++)?\n     * \n     */\n    \n    public int[] countBits(int n) {\n        \n    }\n}",
        "Python": "class Solution(object):\n    def countBits(self, n):\n        \"\"\"\n        Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] is the number of 1's in the binary representation of i.\n        \u00a0\n        Example 1:\n        \n        Input: n = 2\n        Output: [0,1,1]\n        Explanation:\n        0 --> 0\n        1 --> 1\n        2 --> 10\n        \n        Example 2:\n        \n        Input: n = 5\n        Output: [0,1,1,2,1,2]\n        Explanation:\n        0 --> 0\n        1 --> 1\n        2 --> 10\n        3 --> 11\n        4 --> 100\n        5 --> 101\n        \n        \u00a0\n        Constraints:\n        \n        0 <= n <= 105\n        \n        \u00a0\n        Follow up:\n        \n        It is very easy to come up with a solution with a runtime of O(n log n). Can you do it in linear time O(n) and possibly in a single pass?\n        Can you do it without using any built-in function (i.e., like __builtin_popcount in C++)?\n        \n        :type n: int\n        :rtype: List[int]\n        \"\"\"\n        ",
        "JavaScript": "/**\n * Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] is the number of 1's in the binary representation of i.\n * \u00a0\n * Example 1:\n * \n * Input: n = 2\n * Output: [0,1,1]\n * Explanation:\n * 0 --> 0\n * 1 --> 1\n * 2 --> 10\n * \n * Example 2:\n * \n * Input: n = 5\n * Output: [0,1,1,2,1,2]\n * Explanation:\n * 0 --> 0\n * 1 --> 1\n * 2 --> 10\n * 3 --> 11\n * 4 --> 100\n * 5 --> 101\n * \n * \u00a0\n * Constraints:\n * \n * 0 <= n <= 105\n * \n * \u00a0\n * Follow up:\n * \n * It is very easy to come up with a solution with a runtime of O(n log n). Can you do it in linear time O(n) and possibly in a single pass?\n * Can you do it without using any built-in function (i.e., like __builtin_popcount in C++)?\n * \n * @param {number} n\n * @return {number[]}\n */\nvar countBits = function(n) {\n    \n};"
    },
    "unique-substrings-in-wraparound-string": {
        "Java": "class Solution {\n    /**\n     * We define the string base to be the infinite wraparound string of \"abcdefghijklmnopqrstuvwxyz\", so base will look like this:\n     * \n     * \"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....\".\n     * \n     * Given a string s, return the number of unique non-empty substrings of s are present in base.\n     * \u00a0\n     * Example 1:\n     * \n     * Input: s = \"a\"\n     * Output: 1\n     * Explanation: Only the substring \"a\" of s is in base.\n     * \n     * Example 2:\n     * \n     * Input: s = \"cac\"\n     * Output: 2\n     * Explanation: There are two substrings (\"a\", \"c\") of s in base.\n     * \n     * Example 3:\n     * \n     * Input: s = \"zab\"\n     * Output: 6\n     * Explanation: There are six substrings (\"z\", \"a\", \"b\", \"za\", \"ab\", and \"zab\") of s in base.\n     * \n     * \u00a0\n     * Constraints:\n     * \n     * 1 <= s.length <= 105\n     * s consists of lowercase English letters.\n     * \n     */\n    \n    public int findSubstringInWraproundString(String s) {\n        \n    }\n}",
        "Python": "class Solution(object):\n    def findSubstringInWraproundString(self, s):\n        \"\"\"\n        We define the string base to be the infinite wraparound string of \"abcdefghijklmnopqrstuvwxyz\", so base will look like this:\n        \n        \"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....\".\n        \n        Given a string s, return the number of unique non-empty substrings of s are present in base.\n        \u00a0\n        Example 1:\n        \n        Input: s = \"a\"\n        Output: 1\n        Explanation: Only the substring \"a\" of s is in base.\n        \n        Example 2:\n        \n        Input: s = \"cac\"\n        Output: 2\n        Explanation: There are two substrings (\"a\", \"c\") of s in base.\n        \n        Example 3:\n        \n        Input: s = \"zab\"\n        Output: 6\n        Explanation: There are six substrings (\"z\", \"a\", \"b\", \"za\", \"ab\", and \"zab\") of s in base.\n        \n        \u00a0\n        Constraints:\n        \n        1 <= s.length <= 105\n        s consists of lowercase English letters.\n        \n        :type s: str\n        :rtype: int\n        \"\"\"\n        ",
        "JavaScript": "/**\n * We define the string base to be the infinite wraparound string of \"abcdefghijklmnopqrstuvwxyz\", so base will look like this:\n * \n * \"...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....\".\n * \n * Given a string s, return the number of unique non-empty substrings of s are present in base.\n * \u00a0\n * Example 1:\n * \n * Input: s = \"a\"\n * Output: 1\n * Explanation: Only the substring \"a\" of s is in base.\n * \n * Example 2:\n * \n * Input: s = \"cac\"\n * Output: 2\n * Explanation: There are two substrings (\"a\", \"c\") of s in base.\n * \n * Example 3:\n * \n * Input: s = \"zab\"\n * Output: 6\n * Explanation: There are six substrings (\"z\", \"a\", \"b\", \"za\", \"ab\", and \"zab\") of s in base.\n * \n * \u00a0\n * Constraints:\n * \n * 1 <= s.length <= 105\n * s consists of lowercase English letters.\n * \n * @param {string} s\n * @return {number}\n */\nvar findSubstringInWraproundString = function(s) {\n    \n};"
    },
    "ugly-number-ii": {
        "Java": "class Solution {\n    /**\n     * An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\n     * Given an integer n, return the nth ugly number.\n     * \u00a0\n     * Example 1:\n     * \n     * Input: n = 10\n     * Output: 12\n     * Explanation: [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers.\n     * \n     * Example 2:\n     * \n     * Input: n = 1\n     * Output: 1\n     * Explanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.\n     * \n     * \u00a0\n     * Constraints:\n     * \n     * 1 <= n <= 1690\n     * \n     */\n    \n    public int nthUglyNumber(int n) {\n        \n    }\n}",
        "Python": "class Solution(object):\n    def nthUglyNumber(self, n):\n        \"\"\"\n        An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\n        Given an integer n, return the nth ugly number.\n        \u00a0\n        Example 1:\n        \n        Input: n = 10\n        Output: 12\n        Explanation: [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers.\n        \n        Example 2:\n        \n        Input: n = 1\n        Output: 1\n        Explanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.\n        \n        \u00a0\n        Constraints:\n        \n        1 <= n <= 1690\n        \n        :type n: int\n        :rtype: int\n        \"\"\"\n        ",
        "JavaScript": "/**\n * An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\n * Given an integer n, return the nth ugly number.\n * \u00a0\n * Example 1:\n * \n * Input: n = 10\n * Output: 12\n * Explanation: [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers.\n * \n * Example 2:\n * \n * Input: n = 1\n * Output: 1\n * Explanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.\n * \n * \u00a0\n * Constraints:\n * \n * 1 <= n <= 1690\n * \n * @param {number} n\n * @return {number}\n */\nvar nthUglyNumber = function(n) {\n    \n};"
    },
    "super-ugly-number": {
        "Java": "class Solution {\n    /**\n     * A super ugly number is a positive integer whose prime factors are in the array primes.\n     * Given an integer n and an array of integers primes, return the nth super ugly number.\n     * The nth super ugly number is guaranteed to fit in a 32-bit signed integer.\n     * \u00a0\n     * Example 1:\n     * \n     * Input: n = 12, primes = [2,7,13,19]\n     * Output: 32\n     * Explanation: [1,2,4,7,8,13,14,16,19,26,28,32] is the sequence of the first 12 super ugly numbers given primes = [2,7,13,19].\n     * \n     * Example 2:\n     * \n     * Input: n = 1, primes = [2,3,5]\n     * Output: 1\n     * Explanation: 1 has no prime factors, therefore all of its prime factors are in the array primes = [2,3,5].\n     * \n     * \u00a0\n     * Constraints:\n     * \n     * 1 <= n <= 105\n     * 1 <= primes.length <= 100\n     * 2 <= primes[i] <= 1000\n     * primes[i] is guaranteed to be a prime number.\n     * All the values of primes are unique and sorted in ascending order.\n     * \n     */\n    \n    public int nthSuperUglyNumber(int n, int[] primes) {\n        \n    }\n}",
        "Python": "class Solution(object):\n    def nthSuperUglyNumber(self, n, primes):\n        \"\"\"\n        A super ugly number is a positive integer whose prime factors are in the array primes.\n        Given an integer n and an array of integers primes, return the nth super ugly number.\n        The nth super ugly number is guaranteed to fit in a 32-bit signed integer.\n        \u00a0\n        Example 1:\n        \n        Input: n = 12, primes = [2,7,13,19]\n        Output: 32\n        Explanation: [1,2,4,7,8,13,14,16,19,26,28,32] is the sequence of the first 12 super ugly numbers given primes = [2,7,13,19].\n        \n        Example 2:\n        \n        Input: n = 1, primes = [2,3,5]\n        Output: 1\n        Explanation: 1 has no prime factors, therefore all of its prime factors are in the array primes = [2,3,5].\n        \n        \u00a0\n        Constraints:\n        \n        1 <= n <= 105\n        1 <= primes.length <= 100\n        2 <= primes[i] <= 1000\n        primes[i] is guaranteed to be a prime number.\n        All the values of primes are unique and sorted in ascending order.\n        \n        :type n: int\n        :type primes: List[int]\n        :rtype: int\n        \"\"\"\n        ",
        "JavaScript": "/**\n * A super ugly number is a positive integer whose prime factors are in the array primes.\n * Given an integer n and an array of integers primes, return the nth super ugly number.\n * The nth super ugly number is guaranteed to fit in a 32-bit signed integer.\n * \u00a0\n * Example 1:\n * \n * Input: n = 12, primes = [2,7,13,19]\n * Output: 32\n * Explanation: [1,2,4,7,8,13,14,16,19,26,28,32] is the sequence of the first 12 super ugly numbers given primes = [2,7,13,19].\n * \n * Example 2:\n * \n * Input: n = 1, primes = [2,3,5]\n * Output: 1\n * Explanation: 1 has no prime factors, therefore all of its prime factors are in the array primes = [2,3,5].\n * \n * \u00a0\n * Constraints:\n * \n * 1 <= n <= 105\n * 1 <= primes.length <= 100\n * 2 <= primes[i] <= 1000\n * primes[i] is guaranteed to be a prime number.\n * All the values of primes are unique and sorted in ascending order.\n * \n * @param {number} n\n * @param {number[]} primes\n * @return {number}\n */\nvar nthSuperUglyNumber = function(n, primes) {\n    \n};"
    },
    "rotate-function": {
        "Java": "class Solution {\n    /**\n     * You are given an integer array nums of length n.\n     * Assume arrk to be an array obtained by rotating nums by k positions clock-wise. We define the rotation function F on nums as follow:\n     * \n     * F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1].\n     * \n     * Return the maximum value of F(0), F(1), ..., F(n-1).\n     * The test cases are generated so that the answer fits in a 32-bit integer.\n     * \u00a0\n     * Example 1:\n     * \n     * Input: nums = [4,3,2,6]\n     * Output: 26\n     * Explanation:\n     * F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25\n     * F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16\n     * F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23\n     * F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26\n     * So the maximum value of F(0), F(1), F(2), F(3) is F(3) = 26.\n     * \n     * Example 2:\n     * \n     * Input: nums = [100]\n     * Output: 0\n     * \n     * \u00a0\n     * Constraints:\n     * \n     * n == nums.length\n     * 1 <= n <= 105\n     * -100 <= nums[i] <= 100\n     * \n     */\n    \n    public int maxRotateFunction(int[] nums) {\n        \n    }\n}",
        "Python": "class Solution(object):\n    def maxRotateFunction(self, nums):\n        \"\"\"\n        You are given an integer array nums of length n.\n        Assume arrk to be an array obtained by rotating nums by k positions clock-wise. We define the rotation function F on nums as follow:\n        \n        F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1].\n        \n        Return the maximum value of F(0), F(1), ..., F(n-1).\n        The test cases are generated so that the answer fits in a 32-bit integer.\n        \u00a0\n        Example 1:\n        \n        Input: nums = [4,3,2,6]\n        Output: 26\n        Explanation:\n        F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25\n        F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16\n        F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23\n        F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26\n        So the maximum value of F(0), F(1), F(2), F(3) is F(3) = 26.\n        \n        Example 2:\n        \n        Input: nums = [100]\n        Output: 0\n        \n        \u00a0\n        Constraints:\n        \n        n == nums.length\n        1 <= n <= 105\n        -100 <= nums[i] <= 100\n        \n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ",
        "JavaScript": "/**\n * You are given an integer array nums of length n.\n * Assume arrk to be an array obtained by rotating nums by k positions clock-wise. We define the rotation function F on nums as follow:\n * \n * F(k) = 0 * arrk[0] + 1 * arrk[1] + ... + (n - 1) * arrk[n - 1].\n * \n * Return the maximum value of F(0), F(1), ..., F(n-1).\n * The test cases are generated so that the answer fits in a 32-bit integer.\n * \u00a0\n * Example 1:\n * \n * Input: nums = [4,3,2,6]\n * Output: 26\n * Explanation:\n * F(0) = (0 * 4) + (1 * 3) + (2 * 2) + (3 * 6) = 0 + 3 + 4 + 18 = 25\n * F(1) = (0 * 6) + (1 * 4) + (2 * 3) + (3 * 2) = 0 + 4 + 6 + 6 = 16\n * F(2) = (0 * 2) + (1 * 6) + (2 * 4) + (3 * 3) = 0 + 6 + 8 + 9 = 23\n * F(3) = (0 * 3) + (1 * 2) + (2 * 6) + (3 * 4) = 0 + 2 + 12 + 12 = 26\n * So the maximum value of F(0), F(1), F(2), F(3) is F(3) = 26.\n * \n * Example 2:\n * \n * Input: nums = [100]\n * Output: 0\n * \n * \u00a0\n * Constraints:\n * \n * n == nums.length\n * 1 <= n <= 105\n * -100 <= nums[i] <= 100\n * \n * @param {number[]} nums\n * @return {number}\n */\nvar maxRotateFunction = function(nums) {\n    \n};"
    },
    "partition-equal-subset-sum": {
        "Java": "class Solution {\n    /**\n     * Given an integer array nums, return true if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or false otherwise.\n     * \u00a0\n     * Example 1:\n     * \n     * Input: nums = [1,5,11,5]\n     * Output: true\n     * Explanation: The array can be partitioned as [1, 5, 5] and [11].\n     * \n     * Example 2:\n     * \n     * Input: nums = [1,2,3,5]\n     * Output: false\n     * Explanation: The array cannot be partitioned into equal sum subsets.\n     * \n     * \u00a0\n     * Constraints:\n     * \n     * 1 <= nums.length <= 200\n     * 1 <= nums[i] <= 100\n     * \n     */\n    \n    public boolean canPartition(int[] nums) {\n        \n    }\n}",
        "Python": "class Solution(object):\n    def canPartition(self, nums):\n        \"\"\"\n        Given an integer array nums, return true if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or false otherwise.\n        \u00a0\n        Example 1:\n        \n        Input: nums = [1,5,11,5]\n        Output: true\n        Explanation: The array can be partitioned as [1, 5, 5] and [11].\n        \n        Example 2:\n        \n        Input: nums = [1,2,3,5]\n        Output: false\n        Explanation: The array cannot be partitioned into equal sum subsets.\n        \n        \u00a0\n        Constraints:\n        \n        1 <= nums.length <= 200\n        1 <= nums[i] <= 100\n        \n        :type nums: List[int]\n        :rtype: bool\n        \"\"\"\n        ",
        "JavaScript": "/**\n * Given an integer array nums, return true if you can partition the array into two subsets such that the sum of the elements in both subsets is equal or false otherwise.\n * \u00a0\n * Example 1:\n * \n * Input: nums = [1,5,11,5]\n * Output: true\n * Explanation: The array can be partitioned as [1, 5, 5] and [11].\n * \n * Example 2:\n * \n * Input: nums = [1,2,3,5]\n * Output: false\n * Explanation: The array cannot be partitioned into equal sum subsets.\n * \n * \u00a0\n * Constraints:\n * \n * 1 <= nums.length <= 200\n * 1 <= nums[i] <= 100\n * \n * @param {number[]} nums\n * @return {boolean}\n */\nvar canPartition = function(nums) {\n    \n};"
    },
    "non-overlapping-intervals": {
        "Java": "class Solution {\n    /**\n     * Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.\n     * \u00a0\n     * Example 1:\n     * \n     * Input: intervals = [[1,2],[2,3],[3,4],[1,3]]\n     * Output: 1\n     * Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping.\n     * \n     * Example 2:\n     * \n     * Input: intervals = [[1,2],[1,2],[1,2]]\n     * Output: 2\n     * Explanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.\n     * \n     * Example 3:\n     * \n     * Input: intervals = [[1,2],[2,3]]\n     * Output: 0\n     * Explanation: You don't need to remove any of the intervals since they're already non-overlapping.\n     * \n     * \u00a0\n     * Constraints:\n     * \n     * 1 <= intervals.length <= 105\n     * intervals[i].length == 2\n     * -5 * 104 <= starti < endi <= 5 * 104\n     * \n     */\n    \n    public int eraseOverlapIntervals(int[][] intervals) {\n        \n    }\n}",
        "Python": "class Solution(object):\n    def eraseOverlapIntervals(self, intervals):\n        \"\"\"\n        Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.\n        \u00a0\n        Example 1:\n        \n        Input: intervals = [[1,2],[2,3],[3,4],[1,3]]\n        Output: 1\n        Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping.\n        \n        Example 2:\n        \n        Input: intervals = [[1,2],[1,2],[1,2]]\n        Output: 2\n        Explanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.\n        \n        Example 3:\n        \n        Input: intervals = [[1,2],[2,3]]\n        Output: 0\n        Explanation: You don't need to remove any of the intervals since they're already non-overlapping.\n        \n        \u00a0\n        Constraints:\n        \n        1 <= intervals.length <= 105\n        intervals[i].length == 2\n        -5 * 104 <= starti < endi <= 5 * 104\n        \n        :type intervals: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ",
        "JavaScript": "/**\n * Given an array of intervals intervals where intervals[i] = [starti, endi], return the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping.\n * \u00a0\n * Example 1:\n * \n * Input: intervals = [[1,2],[2,3],[3,4],[1,3]]\n * Output: 1\n * Explanation: [1,3] can be removed and the rest of the intervals are non-overlapping.\n * \n * Example 2:\n * \n * Input: intervals = [[1,2],[1,2],[1,2]]\n * Output: 2\n * Explanation: You need to remove two [1,2] to make the rest of the intervals non-overlapping.\n * \n * Example 3:\n * \n * Input: intervals = [[1,2],[2,3]]\n * Output: 0\n * Explanation: You don't need to remove any of the intervals since they're already non-overlapping.\n * \n * \u00a0\n * Constraints:\n * \n * 1 <= intervals.length <= 105\n * intervals[i].length == 2\n * -5 * 104 <= starti < endi <= 5 * 104\n * \n * @param {number[][]} intervals\n * @return {number}\n */\nvar eraseOverlapIntervals = function(intervals) {\n    \n};"
    },
    "longest-increasing-subsequence": {
        "Java": "class Solution {\n    /**\n     * Given an integer array nums, return the length of the longest strictly increasing subsequence.\n     * \u00a0\n     * Example 1:\n     * \n     * Input: nums = [10,9,2,5,3,7,101,18]\n     * Output: 4\n     * Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.\n     * \n     * Example 2:\n     * \n     * Input: nums = [0,1,0,3,2,3]\n     * Output: 4\n     * \n     * Example 3:\n     * \n     * Input: nums = [7,7,7,7,7,7,7]\n     * Output: 1\n     * \n     * \u00a0\n     * Constraints:\n     * \n     * 1 <= nums.length <= 2500\n     * -104 <= nums[i] <= 104\n     * \n     * \u00a0\n     * Follow up:\u00a0Can you come up with an algorithm that runs in\u00a0O(n log(n)) time complexity?\n     * \n     */\n    \n    public int lengthOfLIS(int[] nums) {\n        \n    }\n}",
        "Python": "class Solution(object):\n    def lengthOfLIS(self, nums):\n        \"\"\"\n        Given an integer array nums, return the length of the longest strictly increasing subsequence.\n        \u00a0\n        Example 1:\n        \n        Input: nums = [10,9,2,5,3,7,101,18]\n        Output: 4\n        Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.\n        \n        Example 2:\n        \n        Input: nums = [0,1,0,3,2,3]\n        Output: 4\n        \n        Example 3:\n        \n        Input: nums = [7,7,7,7,7,7,7]\n        Output: 1\n        \n        \u00a0\n        Constraints:\n        \n        1 <= nums.length <= 2500\n        -104 <= nums[i] <= 104\n        \n        \u00a0\n        Follow up:\u00a0Can you come up with an algorithm that runs in\u00a0O(n log(n)) time complexity?\n        \n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ",
        "JavaScript": "/**\n * Given an integer array nums, return the length of the longest strictly increasing subsequence.\n * \u00a0\n * Example 1:\n * \n * Input: nums = [10,9,2,5,3,7,101,18]\n * Output: 4\n * Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.\n * \n * Example 2:\n * \n * Input: nums = [0,1,0,3,2,3]\n * Output: 4\n * \n * Example 3:\n * \n * Input: nums = [7,7,7,7,7,7,7]\n * Output: 1\n * \n * \u00a0\n * Constraints:\n * \n * 1 <= nums.length <= 2500\n * -104 <= nums[i] <= 104\n * \n * \u00a0\n * Follow up:\u00a0Can you come up with an algorithm that runs in\u00a0O(n log(n)) time complexity?\n * \n * @param {number[]} nums\n * @return {number}\n */\nvar lengthOfLIS = function(nums) {\n    \n};"
    },
    "largest-divisible-subset": {
        "Java": "class Solution {\n    /**\n     * Given a set of distinct positive integers nums, return the largest subset answer such that every pair (answer[i], answer[j]) of elements in this subset satisfies:\n     * \n     * answer[i] % answer[j] == 0, or\n     * answer[j] % answer[i] == 0\n     * \n     * If there are multiple solutions, return any of them.\n     * \u00a0\n     * Example 1:\n     * \n     * Input: nums = [1,2,3]\n     * Output: [1,2]\n     * Explanation: [1,3] is also accepted.\n     * \n     * Example 2:\n     * \n     * Input: nums = [1,2,4,8]\n     * Output: [1,2,4,8]\n     * \n     * \u00a0\n     * Constraints:\n     * \n     * 1 <= nums.length <= 1000\n     * 1 <= nums[i] <= 2 * 109\n     * All the integers in nums are unique.\n     * \n     */\n    \n    public List<Integer> largestDivisibleSubset(int[] nums) {\n        \n    }\n}",
        "Python": "class Solution(object):\n    def largestDivisibleSubset(self, nums):\n        \"\"\"\n        Given a set of distinct positive integers nums, return the largest subset answer such that every pair (answer[i], answer[j]) of elements in this subset satisfies:\n        \n        answer[i] % answer[j] == 0, or\n        answer[j] % answer[i] == 0\n        \n        If there are multiple solutions, return any of them.\n        \u00a0\n        Example 1:\n        \n        Input: nums = [1,2,3]\n        Output: [1,2]\n        Explanation: [1,3] is also accepted.\n        \n        Example 2:\n        \n        Input: nums = [1,2,4,8]\n        Output: [1,2,4,8]\n        \n        \u00a0\n        Constraints:\n        \n        1 <= nums.length <= 1000\n        1 <= nums[i] <= 2 * 109\n        All the integers in nums are unique.\n        \n        :type nums: List[int]\n        :rtype: List[int]\n        \"\"\"\n        ",
        "JavaScript": "/**\n * Given a set of distinct positive integers nums, return the largest subset answer such that every pair (answer[i], answer[j]) of elements in this subset satisfies:\n * \n * answer[i] % answer[j] == 0, or\n * answer[j] % answer[i] == 0\n * \n * If there are multiple solutions, return any of them.\n * \u00a0\n * Example 1:\n * \n * Input: nums = [1,2,3]\n * Output: [1,2]\n * Explanation: [1,3] is also accepted.\n * \n * Example 2:\n * \n * Input: nums = [1,2,4,8]\n * Output: [1,2,4,8]\n * \n * \u00a0\n * Constraints:\n * \n * 1 <= nums.length <= 1000\n * 1 <= nums[i] <= 2 * 109\n * All the integers in nums are unique.\n * \n * @param {number[]} nums\n * @return {number[]}\n */\nvar largestDivisibleSubset = function(nums) {\n    \n};"
    },
    "integer-replacement": {
        "Java": "class Solution {\n    /**\n     * Given a positive integer n,\u00a0you can apply one of the following\u00a0operations:\n     * \n     * If n is even, replace n with n / 2.\n     * If n is odd, replace n with either n + 1 or n - 1.\n     * \n     * Return the minimum number of operations needed for n to become 1.\n     * \u00a0\n     * Example 1:\n     * \n     * Input: n = 8\n     * Output: 3\n     * Explanation: 8 -> 4 -> 2 -> 1\n     * \n     * Example 2:\n     * \n     * Input: n = 7\n     * Output: 4\n     * Explanation: 7 -> 8 -> 4 -> 2 -> 1\n     * or 7 -> 6 -> 3 -> 2 -> 1\n     * \n     * Example 3:\n     * \n     * Input: n = 4\n     * Output: 2\n     * \n     * \u00a0\n     * Constraints:\n     * \n     * 1 <= n <= 231 - 1\n     * \n     */\n    \n    public int integerReplacement(int n) {\n        \n    }\n}",
        "Python": "class Solution(object):\n    def integerReplacement(self, n):\n        \"\"\"\n        Given a positive integer n,\u00a0you can apply one of the following\u00a0operations:\n        \n        If n is even, replace n with n / 2.\n        If n is odd, replace n with either n + 1 or n - 1.\n        \n        Return the minimum number of operations needed for n to become 1.\n        \u00a0\n        Example 1:\n        \n        Input: n = 8\n        Output: 3\n        Explanation: 8 -> 4 -> 2 -> 1\n        \n        Example 2:\n        \n        Input: n = 7\n        Output: 4\n        Explanation: 7 -> 8 -> 4 -> 2 -> 1\n        or 7 -> 6 -> 3 -> 2 -> 1\n        \n        Example 3:\n        \n        Input: n = 4\n        Output: 2\n        \n        \u00a0\n        Constraints:\n        \n        1 <= n <= 231 - 1\n        \n        :type n: int\n        :rtype: int\n        \"\"\"\n        ",
        "JavaScript": "/**\n * Given a positive integer n,\u00a0you can apply one of the following\u00a0operations:\n * \n * If n is even, replace n with n / 2.\n * If n is odd, replace n with either n + 1 or n - 1.\n * \n * Return the minimum number of operations needed for n to become 1.\n * \u00a0\n * Example 1:\n * \n * Input: n = 8\n * Output: 3\n * Explanation: 8 -> 4 -> 2 -> 1\n * \n * Example 2:\n * \n * Input: n = 7\n * Output: 4\n * Explanation: 7 -> 8 -> 4 -> 2 -> 1\n * or 7 -> 6 -> 3 -> 2 -> 1\n * \n * Example 3:\n * \n * Input: n = 4\n * Output: 2\n * \n * \u00a0\n * Constraints:\n * \n * 1 <= n <= 231 - 1\n * \n * @param {number} n\n * @return {number}\n */\nvar integerReplacement = function(n) {\n    \n};"
    },
    "integer-break": {
        "Java": "class Solution {\n    /**\n     * Given an integer n, break it into the sum of k positive integers, where k >= 2, and maximize the product of those integers.\n     * Return the maximum product you can get.\n     * \u00a0\n     * Example 1:\n     * \n     * Input: n = 2\n     * Output: 1\n     * Explanation: 2 = 1 + 1, 1 \u00d7 1 = 1.\n     * \n     * Example 2:\n     * \n     * Input: n = 10\n     * Output: 36\n     * Explanation: 10 = 3 + 3 + 4, 3 \u00d7 3 \u00d7 4 = 36.\n     * \n     * \u00a0\n     * Constraints:\n     * \n     * 2 <= n <= 58\n     * \n     */\n    \n    public int integerBreak(int n) {\n        \n    }\n}",
        "Python": "class Solution(object):\n    def integerBreak(self, n):\n        \"\"\"\n        Given an integer n, break it into the sum of k positive integers, where k >= 2, and maximize the product of those integers.\n        Return the maximum product you can get.\n        \u00a0\n        Example 1:\n        \n        Input: n = 2\n        Output: 1\n        Explanation: 2 = 1 + 1, 1 \u00d7 1 = 1.\n        \n        Example 2:\n        \n        Input: n = 10\n        Output: 36\n        Explanation: 10 = 3 + 3 + 4, 3 \u00d7 3 \u00d7 4 = 36.\n        \n        \u00a0\n        Constraints:\n        \n        2 <= n <= 58\n        \n        :type n: int\n        :rtype: int\n        \"\"\"\n        ",
        "JavaScript": "/**\n * Given an integer n, break it into the sum of k positive integers, where k >= 2, and maximize the product of those integers.\n * Return the maximum product you can get.\n * \u00a0\n * Example 1:\n * \n * Input: n = 2\n * Output: 1\n * Explanation: 2 = 1 + 1, 1 \u00d7 1 = 1.\n * \n * Example 2:\n * \n * Input: n = 10\n * Output: 36\n * Explanation: 10 = 3 + 3 + 4, 3 \u00d7 3 \u00d7 4 = 36.\n * \n * \u00a0\n * Constraints:\n * \n * 2 <= n <= 58\n * \n * @param {number} n\n * @return {number}\n */\nvar integerBreak = function(n) {\n    \n};"
    },
    "construct-binary-tree-from-inorder-and-postorder-traversal": {
        "Java": "/**\n     * Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.\n     * \u00a0\n     * Example 1:\n     * \n     * \n     * Input: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]\n     * Output: [3,9,20,null,null,15,7]\n     * \n     * Example 2:\n     * \n     * Input: inorder = [-1], postorder = [-1]\n     * Output: [-1]\n     * \n     * \u00a0\n     * Constraints:\n     * \n     * 1 <= inorder.length <= 3000\n     * postorder.length == inorder.length\n     * -3000 <= inorder[i], postorder[i] <= 3000\n     * inorder and postorder consist of unique values.\n     * Each value of postorder also appears in inorder.\n     * inorder is guaranteed to be the inorder traversal of the tree.\n     * postorder is guaranteed to be the postorder traversal of the tree.\n     * \n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        \n    }\n}",
        "Python": "# Definition for a binary tree node.\n# class TreeNode(object):\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution(object):\n    def buildTree(self, inorder, postorder):\n        \"\"\"\n        Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.\n        \u00a0\n        Example 1:\n        \n        \n        Input: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]\n        Output: [3,9,20,null,null,15,7]\n        \n        Example 2:\n        \n        Input: inorder = [-1], postorder = [-1]\n        Output: [-1]\n        \n        \u00a0\n        Constraints:\n        \n        1 <= inorder.length <= 3000\n        postorder.length == inorder.length\n        -3000 <= inorder[i], postorder[i] <= 3000\n        inorder and postorder consist of unique values.\n        Each value of postorder also appears in inorder.\n        inorder is guaranteed to be the inorder traversal of the tree.\n        postorder is guaranteed to be the postorder traversal of the tree.\n        \n        :type inorder: List[int]\n        :type postorder: List[int]\n        :rtype: TreeNode\n        \"\"\"\n        ",
        "JavaScript": "/**\n * Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.\n * \u00a0\n * Example 1:\n * \n * \n * Input: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]\n * Output: [3,9,20,null,null,15,7]\n * \n * Example 2:\n * \n * Input: inorder = [-1], postorder = [-1]\n * Output: [-1]\n * \n * \u00a0\n * Constraints:\n * \n * 1 <= inorder.length <= 3000\n * postorder.length == inorder.length\n * -3000 <= inorder[i], postorder[i] <= 3000\n * inorder and postorder consist of unique values.\n * Each value of postorder also appears in inorder.\n * inorder is guaranteed to be the inorder traversal of the tree.\n * postorder is guaranteed to be the postorder traversal of the tree.\n * \n * Definition for a binary tree node.\n * function TreeNode(val, left, right) {\n *     this.val = (val===undefined ? 0 : val)\n *     this.left = (left===undefined ? null : left)\n *     this.right = (right===undefined ? null : right)\n * }\n */\n/**\n * @param {number[]} inorder\n * @param {number[]} postorder\n * @return {TreeNode}\n */\nvar buildTree = function(inorder, postorder) {\n    \n};"
    },
    "combination-sum-iv": {
        "Java": "class Solution {\n    /**\n     * Given an array of distinct integers nums and a target integer target, return the number of possible combinations that add up to\u00a0target.\n     * The test cases are generated so that the answer can fit in a 32-bit integer.\n     * \u00a0\n     * Example 1:\n     * \n     * Input: nums = [1,2,3], target = 4\n     * Output: 7\n     * Explanation:\n     * The possible combination ways are:\n     * (1, 1, 1, 1)\n     * (1, 1, 2)\n     * (1, 2, 1)\n     * (1, 3)\n     * (2, 1, 1)\n     * (2, 2)\n     * (3, 1)\n     * Note that different sequences are counted as different combinations.\n     * \n     * Example 2:\n     * \n     * Input: nums = [9], target = 3\n     * Output: 0\n     * \n     * \u00a0\n     * Constraints:\n     * \n     * 1 <= nums.length <= 200\n     * 1 <= nums[i] <= 1000\n     * All the elements of nums are unique.\n     * 1 <= target <= 1000\n     * \n     * \u00a0\n     * Follow up: What if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers?\n     * \n     */\n    \n    public int combinationSum4(int[] nums, int target) {\n        \n    }\n}",
        "Python": "class Solution(object):\n    def combinationSum4(self, nums, target):\n        \"\"\"\n        Given an array of distinct integers nums and a target integer target, return the number of possible combinations that add up to\u00a0target.\n        The test cases are generated so that the answer can fit in a 32-bit integer.\n        \u00a0\n        Example 1:\n        \n        Input: nums = [1,2,3], target = 4\n        Output: 7\n        Explanation:\n        The possible combination ways are:\n        (1, 1, 1, 1)\n        (1, 1, 2)\n        (1, 2, 1)\n        (1, 3)\n        (2, 1, 1)\n        (2, 2)\n        (3, 1)\n        Note that different sequences are counted as different combinations.\n        \n        Example 2:\n        \n        Input: nums = [9], target = 3\n        Output: 0\n        \n        \u00a0\n        Constraints:\n        \n        1 <= nums.length <= 200\n        1 <= nums[i] <= 1000\n        All the elements of nums are unique.\n        1 <= target <= 1000\n        \n        \u00a0\n        Follow up: What if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers?\n        \n        :type nums: List[int]\n        :type target: int\n        :rtype: int\n        \"\"\"\n        ",
        "JavaScript": "/**\n * Given an array of distinct integers nums and a target integer target, return the number of possible combinations that add up to\u00a0target.\n * The test cases are generated so that the answer can fit in a 32-bit integer.\n * \u00a0\n * Example 1:\n * \n * Input: nums = [1,2,3], target = 4\n * Output: 7\n * Explanation:\n * The possible combination ways are:\n * (1, 1, 1, 1)\n * (1, 1, 2)\n * (1, 2, 1)\n * (1, 3)\n * (2, 1, 1)\n * (2, 2)\n * (3, 1)\n * Note that different sequences are counted as different combinations.\n * \n * Example 2:\n * \n * Input: nums = [9], target = 3\n * Output: 0\n * \n * \u00a0\n * Constraints:\n * \n * 1 <= nums.length <= 200\n * 1 <= nums[i] <= 1000\n * All the elements of nums are unique.\n * 1 <= target <= 1000\n * \n * \u00a0\n * Follow up: What if negative numbers are allowed in the given array? How does it change the problem? What limitation we need to add to the question to allow negative numbers?\n * \n * @param {number[]} nums\n * @param {number} target\n * @return {number}\n */\nvar combinationSum4 = function(nums, target) {\n    \n};"
    },
    "coin-change": {
        "Java": "class Solution {\n    /**\n     * You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n     * Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\n     * You may assume that you have an infinite number of each kind of coin.\n     * \u00a0\n     * Example 1:\n     * \n     * Input: coins = [1,2,5], amount = 11\n     * Output: 3\n     * Explanation: 11 = 5 + 5 + 1\n     * \n     * Example 2:\n     * \n     * Input: coins = [2], amount = 3\n     * Output: -1\n     * \n     * Example 3:\n     * \n     * Input: coins = [1], amount = 0\n     * Output: 0\n     * \n     * \u00a0\n     * Constraints:\n     * \n     * 1 <= coins.length <= 12\n     * 1 <= coins[i] <= 231 - 1\n     * 0 <= amount <= 104\n     * \n     */\n    \n    public int coinChange(int[] coins, int amount) {\n        \n    }\n}",
        "Python": "class Solution(object):\n    def coinChange(self, coins, amount):\n        \"\"\"\n        You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n        Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\n        You may assume that you have an infinite number of each kind of coin.\n        \u00a0\n        Example 1:\n        \n        Input: coins = [1,2,5], amount = 11\n        Output: 3\n        Explanation: 11 = 5 + 5 + 1\n        \n        Example 2:\n        \n        Input: coins = [2], amount = 3\n        Output: -1\n        \n        Example 3:\n        \n        Input: coins = [1], amount = 0\n        Output: 0\n        \n        \u00a0\n        Constraints:\n        \n        1 <= coins.length <= 12\n        1 <= coins[i] <= 231 - 1\n        0 <= amount <= 104\n        \n        :type coins: List[int]\n        :type amount: int\n        :rtype: int\n        \"\"\"\n        ",
        "JavaScript": "/**\n * You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n * Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\n * You may assume that you have an infinite number of each kind of coin.\n * \u00a0\n * Example 1:\n * \n * Input: coins = [1,2,5], amount = 11\n * Output: 3\n * Explanation: 11 = 5 + 5 + 1\n * \n * Example 2:\n * \n * Input: coins = [2], amount = 3\n * Output: -1\n * \n * Example 3:\n * \n * Input: coins = [1], amount = 0\n * Output: 0\n * \n * \u00a0\n * Constraints:\n * \n * 1 <= coins.length <= 12\n * 1 <= coins[i] <= 231 - 1\n * 0 <= amount <= 104\n * \n * @param {number[]} coins\n * @param {number} amount\n * @return {number}\n */\nvar coinChange = function(coins, amount) {\n    \n};"
    },
    "count-numbers-with-unique-digits": {
        "Java": "class Solution {\n    /**\n     * Given an integer n, return the count of all numbers with unique digits, x, where 0 <= x < 10n.\n     * \u00a0\n     * Example 1:\n     * \n     * Input: n = 2\n     * Output: 91\n     * Explanation: The answer should be the total numbers in the range of 0 \u2264 x < 100, excluding 11,22,33,44,55,66,77,88,99\n     * \n     * Example 2:\n     * \n     * Input: n = 0\n     * Output: 1\n     * \n     * \u00a0\n     * Constraints:\n     * \n     * 0 <= n <= 8\n     * \n     */\n    \n    public int countNumbersWithUniqueDigits(int n) {\n        \n    }\n}",
        "Python": "class Solution(object):\n    def countNumbersWithUniqueDigits(self, n):\n        \"\"\"\n        Given an integer n, return the count of all numbers with unique digits, x, where 0 <= x < 10n.\n        \u00a0\n        Example 1:\n        \n        Input: n = 2\n        Output: 91\n        Explanation: The answer should be the total numbers in the range of 0 \u2264 x < 100, excluding 11,22,33,44,55,66,77,88,99\n        \n        Example 2:\n        \n        Input: n = 0\n        Output: 1\n        \n        \u00a0\n        Constraints:\n        \n        0 <= n <= 8\n        \n        :type n: int\n        :rtype: int\n        \"\"\"\n        ",
        "JavaScript": "/**\n * Given an integer n, return the count of all numbers with unique digits, x, where 0 <= x < 10n.\n * \u00a0\n * Example 1:\n * \n * Input: n = 2\n * Output: 91\n * Explanation: The answer should be the total numbers in the range of 0 \u2264 x < 100, excluding 11,22,33,44,55,66,77,88,99\n * \n * Example 2:\n * \n * Input: n = 0\n * Output: 1\n * \n * \u00a0\n * Constraints:\n * \n * 0 <= n <= 8\n * \n * @param {number} n\n * @return {number}\n */\nvar countNumbersWithUniqueDigits = function(n) {\n    \n};"
    },
    "can-i-win": {
        "Java": "class Solution {\n    /**\n     * In the \"100 game\" two players take turns adding, to a running total, any integer from 1 to 10. The player who first causes the running total to reach or exceed 100 wins.\n     * What if we change the game so that players cannot re-use integers?\n     * For example, two players might take turns drawing from a common pool of numbers from 1 to 15 without replacement until they reach a total >= 100.\n     * Given two integers maxChoosableInteger and desiredTotal, return true if the first player to move can force a win, otherwise, return false. Assume both players play optimally.\n     * \u00a0\n     * Example 1:\n     * \n     * Input: maxChoosableInteger = 10, desiredTotal = 11\n     * Output: false\n     * Explanation:\n     * No matter which integer the first player choose, the first player will lose.\n     * The first player can choose an integer from 1 up to 10.\n     * If the first player choose 1, the second player can only choose integers from 2 up to 10.\n     * The second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.\n     * Same with other integers chosen by the first player, the second player will always win.\n     * \n     * Example 2:\n     * \n     * Input: maxChoosableInteger = 10, desiredTotal = 0\n     * Output: true\n     * \n     * Example 3:\n     * \n     * Input: maxChoosableInteger = 10, desiredTotal = 1\n     * Output: true\n     * \n     * \u00a0\n     * Constraints:\n     * \n     * 1 <= maxChoosableInteger <= 20\n     * 0 <= desiredTotal <= 300\n     * \n     */\n    \n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\n        \n    }\n}",
        "Python": "class Solution(object):\n    def canIWin(self, maxChoosableInteger, desiredTotal):\n        \"\"\"\n        In the \"100 game\" two players take turns adding, to a running total, any integer from 1 to 10. The player who first causes the running total to reach or exceed 100 wins.\n        What if we change the game so that players cannot re-use integers?\n        For example, two players might take turns drawing from a common pool of numbers from 1 to 15 without replacement until they reach a total >= 100.\n        Given two integers maxChoosableInteger and desiredTotal, return true if the first player to move can force a win, otherwise, return false. Assume both players play optimally.\n        \u00a0\n        Example 1:\n        \n        Input: maxChoosableInteger = 10, desiredTotal = 11\n        Output: false\n        Explanation:\n        No matter which integer the first player choose, the first player will lose.\n        The first player can choose an integer from 1 up to 10.\n        If the first player choose 1, the second player can only choose integers from 2 up to 10.\n        The second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.\n        Same with other integers chosen by the first player, the second player will always win.\n        \n        Example 2:\n        \n        Input: maxChoosableInteger = 10, desiredTotal = 0\n        Output: true\n        \n        Example 3:\n        \n        Input: maxChoosableInteger = 10, desiredTotal = 1\n        Output: true\n        \n        \u00a0\n        Constraints:\n        \n        1 <= maxChoosableInteger <= 20\n        0 <= desiredTotal <= 300\n        \n        :type maxChoosableInteger: int\n        :type desiredTotal: int\n        :rtype: bool\n        \"\"\"\n        ",
        "JavaScript": "/**\n * In the \"100 game\" two players take turns adding, to a running total, any integer from 1 to 10. The player who first causes the running total to reach or exceed 100 wins.\n * What if we change the game so that players cannot re-use integers?\n * For example, two players might take turns drawing from a common pool of numbers from 1 to 15 without replacement until they reach a total >= 100.\n * Given two integers maxChoosableInteger and desiredTotal, return true if the first player to move can force a win, otherwise, return false. Assume both players play optimally.\n * \u00a0\n * Example 1:\n * \n * Input: maxChoosableInteger = 10, desiredTotal = 11\n * Output: false\n * Explanation:\n * No matter which integer the first player choose, the first player will lose.\n * The first player can choose an integer from 1 up to 10.\n * If the first player choose 1, the second player can only choose integers from 2 up to 10.\n * The second player will win by choosing 10 and get a total = 11, which is >= desiredTotal.\n * Same with other integers chosen by the first player, the second player will always win.\n * \n * Example 2:\n * \n * Input: maxChoosableInteger = 10, desiredTotal = 0\n * Output: true\n * \n * Example 3:\n * \n * Input: maxChoosableInteger = 10, desiredTotal = 1\n * Output: true\n * \n * \u00a0\n * Constraints:\n * \n * 1 <= maxChoosableInteger <= 20\n * 0 <= desiredTotal <= 300\n * \n * @param {number} maxChoosableInteger\n * @param {number} desiredTotal\n * @return {boolean}\n */\nvar canIWin = function(maxChoosableInteger, desiredTotal) {\n    \n};"
    },
    "best-time-to-buy-and-sell-stock-with-cooldown": {
        "Java": "class Solution {\n    /**\n     * You are given an array prices where prices[i] is the price of a given stock on the ith day.\n     * Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:\n     * \n     * After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).\n     * \n     * Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n     * \u00a0\n     * Example 1:\n     * \n     * Input: prices = [1,2,3,0,2]\n     * Output: 3\n     * Explanation: transactions = [buy, sell, cooldown, buy, sell]\n     * \n     * Example 2:\n     * \n     * Input: prices = [1]\n     * Output: 0\n     * \n     * \u00a0\n     * Constraints:\n     * \n     * 1 <= prices.length <= 5000\n     * 0 <= prices[i] <= 1000\n     * \n     */\n    \n    public int maxProfit(int[] prices) {\n        \n    }\n}",
        "Python": "class Solution(object):\n    def maxProfit(self, prices):\n        \"\"\"\n        You are given an array prices where prices[i] is the price of a given stock on the ith day.\n        Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:\n        \n        After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).\n        \n        Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n        \u00a0\n        Example 1:\n        \n        Input: prices = [1,2,3,0,2]\n        Output: 3\n        Explanation: transactions = [buy, sell, cooldown, buy, sell]\n        \n        Example 2:\n        \n        Input: prices = [1]\n        Output: 0\n        \n        \u00a0\n        Constraints:\n        \n        1 <= prices.length <= 5000\n        0 <= prices[i] <= 1000\n        \n        :type prices: List[int]\n        :rtype: int\n        \"\"\"\n        ",
        "JavaScript": "/**\n * You are given an array prices where prices[i] is the price of a given stock on the ith day.\n * Find the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:\n * \n * After you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).\n * \n * Note: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n * \u00a0\n * Example 1:\n * \n * Input: prices = [1,2,3,0,2]\n * Output: 3\n * Explanation: transactions = [buy, sell, cooldown, buy, sell]\n * \n * Example 2:\n * \n * Input: prices = [1]\n * Output: 0\n * \n * \u00a0\n * Constraints:\n * \n * 1 <= prices.length <= 5000\n * 0 <= prices[i] <= 1000\n * \n * @param {number[]} prices\n * @return {number}\n */\nvar maxProfit = function(prices) {\n    \n};"
    },
    "arithmetic-slices": {
        "Java": "class Solution {\n    /**\n     * An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\n     * \n     * For example, [1,3,5,7,9], [7,7,7,7], and [3,-1,-5,-9] are arithmetic sequences.\n     * \n     * Given an integer array nums, return the number of arithmetic subarrays of nums.\n     * A subarray is a contiguous subsequence of the array.\n     * \u00a0\n     * Example 1:\n     * \n     * Input: nums = [1,2,3,4]\n     * Output: 3\n     * Explanation: We have 3 arithmetic slices in nums: [1, 2, 3], [2, 3, 4] and [1,2,3,4] itself.\n     * \n     * Example 2:\n     * \n     * Input: nums = [1]\n     * Output: 0\n     * \n     * \u00a0\n     * Constraints:\n     * \n     * 1 <= nums.length <= 5000\n     * -1000 <= nums[i] <= 1000\n     * \n     */\n    \n    public int numberOfArithmeticSlices(int[] nums) {\n        \n    }\n}",
        "Python": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\n        \n        For example, [1,3,5,7,9], [7,7,7,7], and [3,-1,-5,-9] are arithmetic sequences.\n        \n        Given an integer array nums, return the number of arithmetic subarrays of nums.\n        A subarray is a contiguous subsequence of the array.\n        \u00a0\n        Example 1:\n        \n        Input: nums = [1,2,3,4]\n        Output: 3\n        Explanation: We have 3 arithmetic slices in nums: [1, 2, 3], [2, 3, 4] and [1,2,3,4] itself.\n        \n        Example 2:\n        \n        Input: nums = [1]\n        Output: 0\n        \n        \u00a0\n        Constraints:\n        \n        1 <= nums.length <= 5000\n        -1000 <= nums[i] <= 1000\n        \n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ",
        "JavaScript": "/**\n * An integer array is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\n * \n * For example, [1,3,5,7,9], [7,7,7,7], and [3,-1,-5,-9] are arithmetic sequences.\n * \n * Given an integer array nums, return the number of arithmetic subarrays of nums.\n * A subarray is a contiguous subsequence of the array.\n * \u00a0\n * Example 1:\n * \n * Input: nums = [1,2,3,4]\n * Output: 3\n * Explanation: We have 3 arithmetic slices in nums: [1, 2, 3], [2, 3, 4] and [1,2,3,4] itself.\n * \n * Example 2:\n * \n * Input: nums = [1]\n * Output: 0\n * \n * \u00a0\n * Constraints:\n * \n * 1 <= nums.length <= 5000\n * -1000 <= nums[i] <= 1000\n * \n * @param {number[]} nums\n * @return {number}\n */\nvar numberOfArithmeticSlices = function(nums) {\n    \n};"
    },
    "russian-doll-envelopes": {
        "Java": "class Solution {\n    /**\n     * You are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope.\n     * One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.\n     * Return the maximum number of envelopes you can Russian doll (i.e., put one inside the other).\n     * Note: You cannot rotate an envelope.\n     * \u00a0\n     * Example 1:\n     * \n     * Input: envelopes = [[5,4],[6,4],[6,7],[2,3]]\n     * Output: 3\n     * Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]).\n     * \n     * Example 2:\n     * \n     * Input: envelopes = [[1,1],[1,1],[1,1]]\n     * Output: 1\n     * \n     * \u00a0\n     * Constraints:\n     * \n     * 1 <= envelopes.length <= 105\n     * envelopes[i].length == 2\n     * 1 <= wi, hi <= 105\n     * \n     */\n    \n    public int maxEnvelopes(int[][] envelopes) {\n        \n    }\n}",
        "Python": "class Solution(object):\n    def maxEnvelopes(self, envelopes):\n        \"\"\"\n        You are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope.\n        One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.\n        Return the maximum number of envelopes you can Russian doll (i.e., put one inside the other).\n        Note: You cannot rotate an envelope.\n        \u00a0\n        Example 1:\n        \n        Input: envelopes = [[5,4],[6,4],[6,7],[2,3]]\n        Output: 3\n        Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]).\n        \n        Example 2:\n        \n        Input: envelopes = [[1,1],[1,1],[1,1]]\n        Output: 1\n        \n        \u00a0\n        Constraints:\n        \n        1 <= envelopes.length <= 105\n        envelopes[i].length == 2\n        1 <= wi, hi <= 105\n        \n        :type envelopes: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ",
        "JavaScript": "/**\n * You are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope.\n * One envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.\n * Return the maximum number of envelopes you can Russian doll (i.e., put one inside the other).\n * Note: You cannot rotate an envelope.\n * \u00a0\n * Example 1:\n * \n * Input: envelopes = [[5,4],[6,4],[6,7],[2,3]]\n * Output: 3\n * Explanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]).\n * \n * Example 2:\n * \n * Input: envelopes = [[1,1],[1,1],[1,1]]\n * Output: 1\n * \n * \u00a0\n * Constraints:\n * \n * 1 <= envelopes.length <= 105\n * envelopes[i].length == 2\n * 1 <= wi, hi <= 105\n * \n * @param {number[][]} envelopes\n * @return {number}\n */\nvar maxEnvelopes = function(envelopes) {\n    \n};"
    },
    "poor-pigs": {
        "Java": "class Solution {\n    /**\n     * There are buckets buckets of liquid, where exactly one of the buckets is poisonous. To figure out which one is poisonous, you feed some number of (poor) pigs the liquid to see whether they will die or not. Unfortunately, you only have minutesToTest minutes to determine which bucket is poisonous.\n     * You can feed the pigs according to these steps:\n     * \n     * Choose some live pigs to feed.\n     * For each pig, choose which buckets to feed it. The pig will consume all the chosen buckets simultaneously and will take no time. Each pig can feed from any number of buckets, and each bucket can be fed from by any number of pigs.\n     * Wait for minutesToDie minutes. You may not feed any other pigs during this time.\n     * After minutesToDie minutes have passed, any pigs that have been fed the poisonous bucket will die, and all others will survive.\n     * Repeat this process until you run out of time.\n     * \n     * Given buckets, minutesToDie, and minutesToTest, return the minimum number of pigs needed to figure out which bucket is poisonous within the allotted time.\n     * \u00a0\n     * Example 1:\n     * \n     * Input: buckets = 4, minutesToDie = 15, minutesToTest = 15\n     * Output: 2\n     * Explanation: We can determine the poisonous bucket as follows:\n     * At time 0, feed the first pig buckets 1 and 2, and feed the second pig buckets 2 and 3.\n     * At time 15, there are 4 possible outcomes:\n     * - If only the first pig dies, then bucket 1 must be poisonous.\n     * - If only the second pig dies, then bucket 3 must be poisonous.\n     * - If both pigs die, then bucket 2 must be poisonous.\n     * - If neither pig dies, then bucket 4 must be poisonous.\n     * \n     * Example 2:\n     * \n     * Input: buckets = 4, minutesToDie = 15, minutesToTest = 30\n     * Output: 2\n     * Explanation: We can determine the poisonous bucket as follows:\n     * At time 0, feed the first pig bucket 1, and feed the second pig bucket 2.\n     * At time 15, there are 2 possible outcomes:\n     * - If either pig dies, then the poisonous bucket is the one it was fed.\n     * - If neither pig dies, then feed the first pig bucket 3, and feed the second pig bucket 4.\n     * At time 30, one of the two pigs must die, and the poisonous bucket is the one it was fed.\n     * \n     * \u00a0\n     * Constraints:\n     * \n     * 1 <= buckets <= 1000\n     * 1 <=\u00a0minutesToDie <=\u00a0minutesToTest <= 100\n     * \n     */\n    \n    public int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\n        \n    }\n}",
        "Python": "class Solution(object):\n    def poorPigs(self, buckets, minutesToDie, minutesToTest):\n        \"\"\"\n        There are buckets buckets of liquid, where exactly one of the buckets is poisonous. To figure out which one is poisonous, you feed some number of (poor) pigs the liquid to see whether they will die or not. Unfortunately, you only have minutesToTest minutes to determine which bucket is poisonous.\n        You can feed the pigs according to these steps:\n        \n        Choose some live pigs to feed.\n        For each pig, choose which buckets to feed it. The pig will consume all the chosen buckets simultaneously and will take no time. Each pig can feed from any number of buckets, and each bucket can be fed from by any number of pigs.\n        Wait for minutesToDie minutes. You may not feed any other pigs during this time.\n        After minutesToDie minutes have passed, any pigs that have been fed the poisonous bucket will die, and all others will survive.\n        Repeat this process until you run out of time.\n        \n        Given buckets, minutesToDie, and minutesToTest, return the minimum number of pigs needed to figure out which bucket is poisonous within the allotted time.\n        \u00a0\n        Example 1:\n        \n        Input: buckets = 4, minutesToDie = 15, minutesToTest = 15\n        Output: 2\n        Explanation: We can determine the poisonous bucket as follows:\n        At time 0, feed the first pig buckets 1 and 2, and feed the second pig buckets 2 and 3.\n        At time 15, there are 4 possible outcomes:\n        - If only the first pig dies, then bucket 1 must be poisonous.\n        - If only the second pig dies, then bucket 3 must be poisonous.\n        - If both pigs die, then bucket 2 must be poisonous.\n        - If neither pig dies, then bucket 4 must be poisonous.\n        \n        Example 2:\n        \n        Input: buckets = 4, minutesToDie = 15, minutesToTest = 30\n        Output: 2\n        Explanation: We can determine the poisonous bucket as follows:\n        At time 0, feed the first pig bucket 1, and feed the second pig bucket 2.\n        At time 15, there are 2 possible outcomes:\n        - If either pig dies, then the poisonous bucket is the one it was fed.\n        - If neither pig dies, then feed the first pig bucket 3, and feed the second pig bucket 4.\n        At time 30, one of the two pigs must die, and the poisonous bucket is the one it was fed.\n        \n        \u00a0\n        Constraints:\n        \n        1 <= buckets <= 1000\n        1 <=\u00a0minutesToDie <=\u00a0minutesToTest <= 100\n        \n        :type buckets: int\n        :type minutesToDie: int\n        :type minutesToTest: int\n        :rtype: int\n        \"\"\"\n        ",
        "JavaScript": "/**\n * There are buckets buckets of liquid, where exactly one of the buckets is poisonous. To figure out which one is poisonous, you feed some number of (poor) pigs the liquid to see whether they will die or not. Unfortunately, you only have minutesToTest minutes to determine which bucket is poisonous.\n * You can feed the pigs according to these steps:\n * \n * Choose some live pigs to feed.\n * For each pig, choose which buckets to feed it. The pig will consume all the chosen buckets simultaneously and will take no time. Each pig can feed from any number of buckets, and each bucket can be fed from by any number of pigs.\n * Wait for minutesToDie minutes. You may not feed any other pigs during this time.\n * After minutesToDie minutes have passed, any pigs that have been fed the poisonous bucket will die, and all others will survive.\n * Repeat this process until you run out of time.\n * \n * Given buckets, minutesToDie, and minutesToTest, return the minimum number of pigs needed to figure out which bucket is poisonous within the allotted time.\n * \u00a0\n * Example 1:\n * \n * Input: buckets = 4, minutesToDie = 15, minutesToTest = 15\n * Output: 2\n * Explanation: We can determine the poisonous bucket as follows:\n * At time 0, feed the first pig buckets 1 and 2, and feed the second pig buckets 2 and 3.\n * At time 15, there are 4 possible outcomes:\n * - If only the first pig dies, then bucket 1 must be poisonous.\n * - If only the second pig dies, then bucket 3 must be poisonous.\n * - If both pigs die, then bucket 2 must be poisonous.\n * - If neither pig dies, then bucket 4 must be poisonous.\n * \n * Example 2:\n * \n * Input: buckets = 4, minutesToDie = 15, minutesToTest = 30\n * Output: 2\n * Explanation: We can determine the poisonous bucket as follows:\n * At time 0, feed the first pig bucket 1, and feed the second pig bucket 2.\n * At time 15, there are 2 possible outcomes:\n * - If either pig dies, then the poisonous bucket is the one it was fed.\n * - If neither pig dies, then feed the first pig bucket 3, and feed the second pig bucket 4.\n * At time 30, one of the two pigs must die, and the poisonous bucket is the one it was fed.\n * \n * \u00a0\n * Constraints:\n * \n * 1 <= buckets <= 1000\n * 1 <=\u00a0minutesToDie <=\u00a0minutesToTest <= 100\n * \n * @param {number} buckets\n * @param {number} minutesToDie\n * @param {number} minutesToTest\n * @return {number}\n */\nvar poorPigs = function(buckets, minutesToDie, minutesToTest) {\n    \n};"
    },
    "distinct-subsequences": {
        "Java": "class Solution {\n    /**\n     * Given two strings s and t, return the number of distinct subsequences of s which equals t.\n     * The test cases are generated so that the answer fits on a 32-bit signed integer.\n     * \u00a0\n     * Example 1:\n     * \n     * Input: s = \"rabbbit\", t = \"rabbit\"\n     * Output: 3\n     * Explanation:\n     * As shown below, there are 3 ways you can generate \"rabbit\" from s.\n     * rabbbit\n     * rabbbit\n     * rabbbit\n     * \n     * Example 2:\n     * \n     * Input: s = \"babgbag\", t = \"bag\"\n     * Output: 5\n     * Explanation:\n     * As shown below, there are 5 ways you can generate \"bag\" from s.\n     * babgbag\n     * babgbag\n     * babgbag\n     * babgbag\n     * babgbag\n     * \u00a0\n     * Constraints:\n     * \n     * 1 <= s.length, t.length <= 1000\n     * s and t consist of English letters.\n     * \n     */\n    \n    public int numDistinct(String s, String t) {\n        \n    }\n}",
        "Python": "class Solution(object):\n    def numDistinct(self, s, t):\n        \"\"\"\n        Given two strings s and t, return the number of distinct subsequences of s which equals t.\n        The test cases are generated so that the answer fits on a 32-bit signed integer.\n        \u00a0\n        Example 1:\n        \n        Input: s = \"rabbbit\", t = \"rabbit\"\n        Output: 3\n        Explanation:\n        As shown below, there are 3 ways you can generate \"rabbit\" from s.\n        rabbbit\n        rabbbit\n        rabbbit\n        \n        Example 2:\n        \n        Input: s = \"babgbag\", t = \"bag\"\n        Output: 5\n        Explanation:\n        As shown below, there are 5 ways you can generate \"bag\" from s.\n        babgbag\n        babgbag\n        babgbag\n        babgbag\n        babgbag\n        \u00a0\n        Constraints:\n        \n        1 <= s.length, t.length <= 1000\n        s and t consist of English letters.\n        \n        :type s: str\n        :type t: str\n        :rtype: int\n        \"\"\"\n        ",
        "JavaScript": "/**\n * Given two strings s and t, return the number of distinct subsequences of s which equals t.\n * The test cases are generated so that the answer fits on a 32-bit signed integer.\n * \u00a0\n * Example 1:\n * \n * Input: s = \"rabbbit\", t = \"rabbit\"\n * Output: 3\n * Explanation:\n * As shown below, there are 3 ways you can generate \"rabbit\" from s.\n * rabbbit\n * rabbbit\n * rabbbit\n * \n * Example 2:\n * \n * Input: s = \"babgbag\", t = \"bag\"\n * Output: 5\n * Explanation:\n * As shown below, there are 5 ways you can generate \"bag\" from s.\n * babgbag\n * babgbag\n * babgbag\n * babgbag\n * babgbag\n * \u00a0\n * Constraints:\n * \n * 1 <= s.length, t.length <= 1000\n * s and t consist of English letters.\n * \n * @param {string} s\n * @param {string} t\n * @return {number}\n */\nvar numDistinct = function(s, t) {\n    \n};"
    },
    "burst-balloons": {
        "Java": "class Solution {\n    /**\n     * You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array nums. You are asked to burst all the balloons.\n     * If you burst the ith balloon, you will get nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it.\n     * Return the maximum coins you can collect by bursting the balloons wisely.\n     * \u00a0\n     * Example 1:\n     * \n     * Input: nums = [3,1,5,8]\n     * Output: 167\n     * Explanation:\n     * nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []\n     * coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167\n     * Example 2:\n     * \n     * Input: nums = [1,5]\n     * Output: 10\n     * \n     * \u00a0\n     * Constraints:\n     * \n     * n == nums.length\n     * 1 <= n <= 300\n     * 0 <= nums[i] <= 100\n     * \n     */\n    \n    public int maxCoins(int[] nums) {\n        \n    }\n}",
        "Python": "class Solution(object):\n    def maxCoins(self, nums):\n        \"\"\"\n        You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array nums. You are asked to burst all the balloons.\n        If you burst the ith balloon, you will get nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it.\n        Return the maximum coins you can collect by bursting the balloons wisely.\n        \u00a0\n        Example 1:\n        \n        Input: nums = [3,1,5,8]\n        Output: 167\n        Explanation:\n        nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []\n        coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167\n        Example 2:\n        \n        Input: nums = [1,5]\n        Output: 10\n        \n        \u00a0\n        Constraints:\n        \n        n == nums.length\n        1 <= n <= 300\n        0 <= nums[i] <= 100\n        \n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ",
        "JavaScript": "/**\n * You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array nums. You are asked to burst all the balloons.\n * If you burst the ith balloon, you will get nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it.\n * Return the maximum coins you can collect by bursting the balloons wisely.\n * \u00a0\n * Example 1:\n * \n * Input: nums = [3,1,5,8]\n * Output: 167\n * Explanation:\n * nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []\n * coins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167\n * Example 2:\n * \n * Input: nums = [1,5]\n * Output: 10\n * \n * \u00a0\n * Constraints:\n * \n * n == nums.length\n * 1 <= n <= 300\n * 0 <= nums[i] <= 100\n * \n * @param {number[]} nums\n * @return {number}\n */\nvar maxCoins = function(nums) {\n    \n};"
    },
    "split-array-largest-sum": {
        "Java": "class Solution {\n    /**\n     * Given an integer array nums and an integer k, split nums into k non-empty subarrays such that the largest sum of any subarray is minimized.\n     * Return the minimized largest sum of the split.\n     * A subarray is a contiguous part of the array.\n     * \u00a0\n     * Example 1:\n     * \n     * Input: nums = [7,2,5,10,8], k = 2\n     * Output: 18\n     * Explanation: There are four ways to split nums into two subarrays.\n     * The best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.\n     * \n     * Example 2:\n     * \n     * Input: nums = [1,2,3,4,5], k = 2\n     * Output: 9\n     * Explanation: There are four ways to split nums into two subarrays.\n     * The best way is to split it into [1,2,3] and [4,5], where the largest sum among the two subarrays is only 9.\n     * \n     * \u00a0\n     * Constraints:\n     * \n     * 1 <= nums.length <= 1000\n     * 0 <= nums[i] <= 106\n     * 1 <= k <= min(50, nums.length)\n     * \n     */\n    \n    public int splitArray(int[] nums, int k) {\n        \n    }\n}",
        "Python": "class Solution(object):\n    def splitArray(self, nums, k):\n        \"\"\"\n        Given an integer array nums and an integer k, split nums into k non-empty subarrays such that the largest sum of any subarray is minimized.\n        Return the minimized largest sum of the split.\n        A subarray is a contiguous part of the array.\n        \u00a0\n        Example 1:\n        \n        Input: nums = [7,2,5,10,8], k = 2\n        Output: 18\n        Explanation: There are four ways to split nums into two subarrays.\n        The best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.\n        \n        Example 2:\n        \n        Input: nums = [1,2,3,4,5], k = 2\n        Output: 9\n        Explanation: There are four ways to split nums into two subarrays.\n        The best way is to split it into [1,2,3] and [4,5], where the largest sum among the two subarrays is only 9.\n        \n        \u00a0\n        Constraints:\n        \n        1 <= nums.length <= 1000\n        0 <= nums[i] <= 106\n        1 <= k <= min(50, nums.length)\n        \n        :type nums: List[int]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ",
        "JavaScript": "/**\n * Given an integer array nums and an integer k, split nums into k non-empty subarrays such that the largest sum of any subarray is minimized.\n * Return the minimized largest sum of the split.\n * A subarray is a contiguous part of the array.\n * \u00a0\n * Example 1:\n * \n * Input: nums = [7,2,5,10,8], k = 2\n * Output: 18\n * Explanation: There are four ways to split nums into two subarrays.\n * The best way is to split it into [7,2,5] and [10,8], where the largest sum among the two subarrays is only 18.\n * \n * Example 2:\n * \n * Input: nums = [1,2,3,4,5], k = 2\n * Output: 9\n * Explanation: There are four ways to split nums into two subarrays.\n * The best way is to split it into [1,2,3] and [4,5], where the largest sum among the two subarrays is only 9.\n * \n * \u00a0\n * Constraints:\n * \n * 1 <= nums.length <= 1000\n * 0 <= nums[i] <= 106\n * 1 <= k <= min(50, nums.length)\n * \n * @param {number[]} nums\n * @param {number} k\n * @return {number}\n */\nvar splitArray = function(nums, k) {\n    \n};"
    },
    "number-of-digit-one": {
        "Java": "class Solution {\n    /**\n     * Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.\n     * \u00a0\n     * Example 1:\n     * \n     * Input: n = 13\n     * Output: 6\n     * \n     * Example 2:\n     * \n     * Input: n = 0\n     * Output: 0\n     * \n     * \u00a0\n     * Constraints:\n     * \n     * 0 <= n <= 109\n     * \n     */\n    \n    public int countDigitOne(int n) {\n        \n    }\n}",
        "Python": "class Solution(object):\n    def countDigitOne(self, n):\n        \"\"\"\n        Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.\n        \u00a0\n        Example 1:\n        \n        Input: n = 13\n        Output: 6\n        \n        Example 2:\n        \n        Input: n = 0\n        Output: 0\n        \n        \u00a0\n        Constraints:\n        \n        0 <= n <= 109\n        \n        :type n: int\n        :rtype: int\n        \"\"\"\n        ",
        "JavaScript": "/**\n * Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.\n * \u00a0\n * Example 1:\n * \n * Input: n = 13\n * Output: 6\n * \n * Example 2:\n * \n * Input: n = 0\n * Output: 0\n * \n * \u00a0\n * Constraints:\n * \n * 0 <= n <= 109\n * \n * @param {number} n\n * @return {number}\n */\nvar countDigitOne = function(n) {\n    \n};"
    },
    "max-sum-of-rectangle-no-larger-than-k": {
        "Java": "class Solution {\n    /**\n     * Given an m x n matrix matrix and an integer k, return the max sum of a rectangle in the matrix such that its sum is no larger than k.\n     * It is guaranteed that there will be a rectangle with a sum no larger than k.\n     * \u00a0\n     * Example 1:\n     * \n     * \n     * Input: matrix = [[1,0,1],[0,-2,3]], k = 2\n     * Output: 2\n     * Explanation: Because the sum of the blue rectangle [[0, 1], [-2, 3]] is 2, and 2 is the max number no larger than k (k = 2).\n     * \n     * Example 2:\n     * \n     * Input: matrix = [[2,2,-1]], k = 3\n     * Output: 3\n     * \n     * \u00a0\n     * Constraints:\n     * \n     * m == matrix.length\n     * n == matrix[i].length\n     * 1 <= m, n <= 100\n     * -100 <= matrix[i][j] <= 100\n     * -105 <= k <= 105\n     * \n     * \u00a0\n     * Follow up: What if the number of rows is much larger than the number of columns?\n     * \n     */\n    \n    public int maxSumSubmatrix(int[][] matrix, int k) {\n        \n    }\n}",
        "Python": "class Solution(object):\n    def maxSumSubmatrix(self, matrix, k):\n        \"\"\"\n        Given an m x n matrix matrix and an integer k, return the max sum of a rectangle in the matrix such that its sum is no larger than k.\n        It is guaranteed that there will be a rectangle with a sum no larger than k.\n        \u00a0\n        Example 1:\n        \n        \n        Input: matrix = [[1,0,1],[0,-2,3]], k = 2\n        Output: 2\n        Explanation: Because the sum of the blue rectangle [[0, 1], [-2, 3]] is 2, and 2 is the max number no larger than k (k = 2).\n        \n        Example 2:\n        \n        Input: matrix = [[2,2,-1]], k = 3\n        Output: 3\n        \n        \u00a0\n        Constraints:\n        \n        m == matrix.length\n        n == matrix[i].length\n        1 <= m, n <= 100\n        -100 <= matrix[i][j] <= 100\n        -105 <= k <= 105\n        \n        \u00a0\n        Follow up: What if the number of rows is much larger than the number of columns?\n        \n        :type matrix: List[List[int]]\n        :type k: int\n        :rtype: int\n        \"\"\"\n        ",
        "JavaScript": "/**\n * Given an m x n matrix matrix and an integer k, return the max sum of a rectangle in the matrix such that its sum is no larger than k.\n * It is guaranteed that there will be a rectangle with a sum no larger than k.\n * \u00a0\n * Example 1:\n * \n * \n * Input: matrix = [[1,0,1],[0,-2,3]], k = 2\n * Output: 2\n * Explanation: Because the sum of the blue rectangle [[0, 1], [-2, 3]] is 2, and 2 is the max number no larger than k (k = 2).\n * \n * Example 2:\n * \n * Input: matrix = [[2,2,-1]], k = 3\n * Output: 3\n * \n * \u00a0\n * Constraints:\n * \n * m == matrix.length\n * n == matrix[i].length\n * 1 <= m, n <= 100\n * -100 <= matrix[i][j] <= 100\n * -105 <= k <= 105\n * \n * \u00a0\n * Follow up: What if the number of rows is much larger than the number of columns?\n * \n * @param {number[][]} matrix\n * @param {number} k\n * @return {number}\n */\nvar maxSumSubmatrix = function(matrix, k) {\n    \n};"
    },
    "longest-increasing-path-in-a-matrix": {
        "Java": "class Solution {\n    /**\n     * Given an m x n integers matrix, return the length of the longest increasing path in matrix.\n     * From each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).\n     * \u00a0\n     * Example 1:\n     * \n     * \n     * Input: matrix = [[9,9,4],[6,6,8],[2,1,1]]\n     * Output: 4\n     * Explanation: The longest increasing path is [1, 2, 6, 9].\n     * \n     * Example 2:\n     * \n     * \n     * Input: matrix = [[3,4,5],[3,2,6],[2,2,1]]\n     * Output: 4\n     * Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.\n     * \n     * Example 3:\n     * \n     * Input: matrix = [[1]]\n     * Output: 1\n     * \n     * \u00a0\n     * Constraints:\n     * \n     * m == matrix.length\n     * n == matrix[i].length\n     * 1 <= m, n <= 200\n     * 0 <= matrix[i][j] <= 231 - 1\n     * \n     */\n    \n    public int longestIncreasingPath(int[][] matrix) {\n        \n    }\n}",
        "Python": "class Solution(object):\n    def longestIncreasingPath(self, matrix):\n        \"\"\"\n        Given an m x n integers matrix, return the length of the longest increasing path in matrix.\n        From each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).\n        \u00a0\n        Example 1:\n        \n        \n        Input: matrix = [[9,9,4],[6,6,8],[2,1,1]]\n        Output: 4\n        Explanation: The longest increasing path is [1, 2, 6, 9].\n        \n        Example 2:\n        \n        \n        Input: matrix = [[3,4,5],[3,2,6],[2,2,1]]\n        Output: 4\n        Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.\n        \n        Example 3:\n        \n        Input: matrix = [[1]]\n        Output: 1\n        \n        \u00a0\n        Constraints:\n        \n        m == matrix.length\n        n == matrix[i].length\n        1 <= m, n <= 200\n        0 <= matrix[i][j] <= 231 - 1\n        \n        :type matrix: List[List[int]]\n        :rtype: int\n        \"\"\"\n        ",
        "JavaScript": "/**\n * Given an m x n integers matrix, return the length of the longest increasing path in matrix.\n * From each cell, you can either move in four directions: left, right, up, or down. You may not move diagonally or move outside the boundary (i.e., wrap-around is not allowed).\n * \u00a0\n * Example 1:\n * \n * \n * Input: matrix = [[9,9,4],[6,6,8],[2,1,1]]\n * Output: 4\n * Explanation: The longest increasing path is [1, 2, 6, 9].\n * \n * Example 2:\n * \n * \n * Input: matrix = [[3,4,5],[3,2,6],[2,2,1]]\n * Output: 4\n * Explanation: The longest increasing path is [3, 4, 5, 6]. Moving diagonally is not allowed.\n * \n * Example 3:\n * \n * Input: matrix = [[1]]\n * Output: 1\n * \n * \u00a0\n * Constraints:\n * \n * m == matrix.length\n * n == matrix[i].length\n * 1 <= m, n <= 200\n * 0 <= matrix[i][j] <= 231 - 1\n * \n * @param {number[][]} matrix\n * @return {number}\n */\nvar longestIncreasingPath = function(matrix) {\n    \n};"
    },
    "frog-jump": {
        "Java": "class Solution {\n    /**\n     * A frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.\n     * Given a list of stones\u00a0positions (in units) in sorted ascending order, determine if the frog can cross the river by landing on the last stone. Initially, the frog is on the first stone and assumes the first jump must be 1 unit.\n     * If the frog's last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.\n     * \u00a0\n     * Example 1:\n     * \n     * Input: stones = [0,1,3,5,6,8,12,17]\n     * Output: true\n     * Explanation: The frog can jump to the last stone by jumping 1 unit to the 2nd stone, then 2 units to the 3rd stone, then 2 units to the 4th stone, then 3 units to the 6th stone, 4 units to the 7th stone, and 5 units to the 8th stone.\n     * \n     * Example 2:\n     * \n     * Input: stones = [0,1,2,3,4,8,9,11]\n     * Output: false\n     * Explanation: There is no way to jump to the last stone as the gap between the 5th and 6th stone is too large.\n     * \n     * \u00a0\n     * Constraints:\n     * \n     * 2 <= stones.length <= 2000\n     * 0 <= stones[i] <= 231 - 1\n     * stones[0] == 0\n     * stones\u00a0is sorted in a strictly increasing order.\n     * \n     */\n    \n    public boolean canCross(int[] stones) {\n        \n    }\n}",
        "Python": "class Solution(object):\n    def canCross(self, stones):\n        \"\"\"\n        A frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.\n        Given a list of stones\u00a0positions (in units) in sorted ascending order, determine if the frog can cross the river by landing on the last stone. Initially, the frog is on the first stone and assumes the first jump must be 1 unit.\n        If the frog's last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.\n        \u00a0\n        Example 1:\n        \n        Input: stones = [0,1,3,5,6,8,12,17]\n        Output: true\n        Explanation: The frog can jump to the last stone by jumping 1 unit to the 2nd stone, then 2 units to the 3rd stone, then 2 units to the 4th stone, then 3 units to the 6th stone, 4 units to the 7th stone, and 5 units to the 8th stone.\n        \n        Example 2:\n        \n        Input: stones = [0,1,2,3,4,8,9,11]\n        Output: false\n        Explanation: There is no way to jump to the last stone as the gap between the 5th and 6th stone is too large.\n        \n        \u00a0\n        Constraints:\n        \n        2 <= stones.length <= 2000\n        0 <= stones[i] <= 231 - 1\n        stones[0] == 0\n        stones\u00a0is sorted in a strictly increasing order.\n        \n        :type stones: List[int]\n        :rtype: bool\n        \"\"\"\n        ",
        "JavaScript": "/**\n * A frog is crossing a river. The river is divided into some number of units, and at each unit, there may or may not exist a stone. The frog can jump on a stone, but it must not jump into the water.\n * Given a list of stones\u00a0positions (in units) in sorted ascending order, determine if the frog can cross the river by landing on the last stone. Initially, the frog is on the first stone and assumes the first jump must be 1 unit.\n * If the frog's last jump was k units, its next jump must be either k - 1, k, or k + 1 units. The frog can only jump in the forward direction.\n * \u00a0\n * Example 1:\n * \n * Input: stones = [0,1,3,5,6,8,12,17]\n * Output: true\n * Explanation: The frog can jump to the last stone by jumping 1 unit to the 2nd stone, then 2 units to the 3rd stone, then 2 units to the 4th stone, then 3 units to the 6th stone, 4 units to the 7th stone, and 5 units to the 8th stone.\n * \n * Example 2:\n * \n * Input: stones = [0,1,2,3,4,8,9,11]\n * Output: false\n * Explanation: There is no way to jump to the last stone as the gap between the 5th and 6th stone is too large.\n * \n * \u00a0\n * Constraints:\n * \n * 2 <= stones.length <= 2000\n * 0 <= stones[i] <= 231 - 1\n * stones[0] == 0\n * stones\u00a0is sorted in a strictly increasing order.\n * \n * @param {number[]} stones\n * @return {boolean}\n */\nvar canCross = function(stones) {\n    \n};"
    },
    "count-the-repetitions": {
        "Java": "class Solution {\n    /**\n     * We define str = [s, n] as the string str which consists of the string s concatenated n times.\n     * \n     * For example, str == [\"abc\", 3] ==\"abcabcabc\".\n     * \n     * We define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n     * \n     * For example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n     * \n     * You are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\n     * Return the maximum integer m such that str = [str2, m] can be obtained from str1.\n     * \u00a0\n     * Example 1:\n     * Input: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\n     * Output: 2\n     * Example 2:\n     * Input: s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\n     * Output: 1\n     * \n     * \u00a0\n     * Constraints:\n     * \n     * 1 <= s1.length, s2.length <= 100\n     * s1 and s2 consist of lowercase English letters.\n     * 1 <= n1, n2 <= 106\n     * \n     */\n    \n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\n        \n    }\n}",
        "Python": "class Solution(object):\n    def getMaxRepetitions(self, s1, n1, s2, n2):\n        \"\"\"\n        We define str = [s, n] as the string str which consists of the string s concatenated n times.\n        \n        For example, str == [\"abc\", 3] ==\"abcabcabc\".\n        \n        We define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n        \n        For example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n        \n        You are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\n        Return the maximum integer m such that str = [str2, m] can be obtained from str1.\n        \u00a0\n        Example 1:\n        Input: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\n        Output: 2\n        Example 2:\n        Input: s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\n        Output: 1\n        \n        \u00a0\n        Constraints:\n        \n        1 <= s1.length, s2.length <= 100\n        s1 and s2 consist of lowercase English letters.\n        1 <= n1, n2 <= 106\n        \n        :type s1: str\n        :type n1: int\n        :type s2: str\n        :type n2: int\n        :rtype: int\n        \"\"\"\n        ",
        "JavaScript": "/**\n * We define str = [s, n] as the string str which consists of the string s concatenated n times.\n * \n * For example, str == [\"abc\", 3] ==\"abcabcabc\".\n * \n * We define that string s1 can be obtained from string s2 if we can remove some characters from s2 such that it becomes s1.\n * \n * For example, s1 = \"abc\" can be obtained from s2 = \"abdbec\" based on our definition by removing the bolded underlined characters.\n * \n * You are given two strings s1 and s2 and two integers n1 and n2. You have the two strings str1 = [s1, n1] and str2 = [s2, n2].\n * Return the maximum integer m such that str = [str2, m] can be obtained from str1.\n * \u00a0\n * Example 1:\n * Input: s1 = \"acb\", n1 = 4, s2 = \"ab\", n2 = 2\n * Output: 2\n * Example 2:\n * Input: s1 = \"acb\", n1 = 1, s2 = \"acb\", n2 = 1\n * Output: 1\n * \n * \u00a0\n * Constraints:\n * \n * 1 <= s1.length, s2.length <= 100\n * s1 and s2 consist of lowercase English letters.\n * 1 <= n1, n2 <= 106\n * \n * @param {string} s1\n * @param {number} n1\n * @param {string} s2\n * @param {number} n2\n * @return {number}\n */\nvar getMaxRepetitions = function(s1, n1, s2, n2) {\n    \n};"
    },
    "concatenated-words": {
        "Java": "class Solution {\n    /**\n     * Given an array of strings words (without duplicates), return all the concatenated words in the given list of words.\n     * A concatenated word is defined as a string that is comprised entirely of at least two shorter words (not necessarily distinct)\u00a0in the given array.\n     * \u00a0\n     * Example 1:\n     * \n     * Input: words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]\n     * Output: [\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]\n     * Explanation: \"catsdogcats\" can be concatenated by \"cats\", \"dog\" and \"cats\"; \n     * \"dogcatsdog\" can be concatenated by \"dog\", \"cats\" and \"dog\"; \n     * \"ratcatdogcat\" can be concatenated by \"rat\", \"cat\", \"dog\" and \"cat\".\n     * Example 2:\n     * \n     * Input: words = [\"cat\",\"dog\",\"catdog\"]\n     * Output: [\"catdog\"]\n     * \n     * \u00a0\n     * Constraints:\n     * \n     * 1 <= words.length <= 104\n     * 1 <= words[i].length <= 30\n     * words[i] consists of only lowercase English letters.\n     * All the strings of words are unique.\n     * 1 <= sum(words[i].length) <= 105\n     * \n     */\n    \n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\n        \n    }\n}",
        "Python": "class Solution(object):\n    def findAllConcatenatedWordsInADict(self, words):\n        \"\"\"\n        Given an array of strings words (without duplicates), return all the concatenated words in the given list of words.\n        A concatenated word is defined as a string that is comprised entirely of at least two shorter words (not necessarily distinct)\u00a0in the given array.\n        \u00a0\n        Example 1:\n        \n        Input: words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]\n        Output: [\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]\n        Explanation: \"catsdogcats\" can be concatenated by \"cats\", \"dog\" and \"cats\"; \n        \"dogcatsdog\" can be concatenated by \"dog\", \"cats\" and \"dog\"; \n        \"ratcatdogcat\" can be concatenated by \"rat\", \"cat\", \"dog\" and \"cat\".\n        Example 2:\n        \n        Input: words = [\"cat\",\"dog\",\"catdog\"]\n        Output: [\"catdog\"]\n        \n        \u00a0\n        Constraints:\n        \n        1 <= words.length <= 104\n        1 <= words[i].length <= 30\n        words[i] consists of only lowercase English letters.\n        All the strings of words are unique.\n        1 <= sum(words[i].length) <= 105\n        \n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        ",
        "JavaScript": "/**\n * Given an array of strings words (without duplicates), return all the concatenated words in the given list of words.\n * A concatenated word is defined as a string that is comprised entirely of at least two shorter words (not necessarily distinct)\u00a0in the given array.\n * \u00a0\n * Example 1:\n * \n * Input: words = [\"cat\",\"cats\",\"catsdogcats\",\"dog\",\"dogcatsdog\",\"hippopotamuses\",\"rat\",\"ratcatdogcat\"]\n * Output: [\"catsdogcats\",\"dogcatsdog\",\"ratcatdogcat\"]\n * Explanation: \"catsdogcats\" can be concatenated by \"cats\", \"dog\" and \"cats\"; \n * \"dogcatsdog\" can be concatenated by \"dog\", \"cats\" and \"dog\"; \n * \"ratcatdogcat\" can be concatenated by \"rat\", \"cat\", \"dog\" and \"cat\".\n * Example 2:\n * \n * Input: words = [\"cat\",\"dog\",\"catdog\"]\n * Output: [\"catdog\"]\n * \n * \u00a0\n * Constraints:\n * \n * 1 <= words.length <= 104\n * 1 <= words[i].length <= 30\n * words[i] consists of only lowercase English letters.\n * All the strings of words are unique.\n * 1 <= sum(words[i].length) <= 105\n * \n * @param {string[]} words\n * @return {string[]}\n */\nvar findAllConcatenatedWordsInADict = function(words) {\n    \n};"
    },
    "arithmetic-slices-ii-subsequence": {
        "Java": "class Solution {\n    /**\n     * Given an integer array nums, return the number of all the arithmetic subsequences of nums.\n     * A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\n     * \n     * For example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences.\n     * For example, [1, 1, 2, 5, 7] is not an arithmetic sequence.\n     * \n     * A subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.\n     * \n     * For example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10].\n     * \n     * The test cases are generated so that the answer fits in 32-bit integer.\n     * \u00a0\n     * Example 1:\n     * \n     * Input: nums = [2,4,6,8,10]\n     * Output: 7\n     * Explanation: All arithmetic subsequence slices are:\n     * [2,4,6]\n     * [4,6,8]\n     * [6,8,10]\n     * [2,4,6,8]\n     * [4,6,8,10]\n     * [2,4,6,8,10]\n     * [2,6,10]\n     * \n     * Example 2:\n     * \n     * Input: nums = [7,7,7,7,7]\n     * Output: 16\n     * Explanation: Any subsequence of this array is arithmetic.\n     * \n     * \u00a0\n     * Constraints:\n     * \n     * 1\u00a0 <= nums.length <= 1000\n     * -231 <= nums[i] <= 231 - 1\n     * \n     */\n    \n    public int numberOfArithmeticSlices(int[] nums) {\n        \n    }\n}",
        "Python": "class Solution(object):\n    def numberOfArithmeticSlices(self, nums):\n        \"\"\"\n        Given an integer array nums, return the number of all the arithmetic subsequences of nums.\n        A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\n        \n        For example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences.\n        For example, [1, 1, 2, 5, 7] is not an arithmetic sequence.\n        \n        A subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.\n        \n        For example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10].\n        \n        The test cases are generated so that the answer fits in 32-bit integer.\n        \u00a0\n        Example 1:\n        \n        Input: nums = [2,4,6,8,10]\n        Output: 7\n        Explanation: All arithmetic subsequence slices are:\n        [2,4,6]\n        [4,6,8]\n        [6,8,10]\n        [2,4,6,8]\n        [4,6,8,10]\n        [2,4,6,8,10]\n        [2,6,10]\n        \n        Example 2:\n        \n        Input: nums = [7,7,7,7,7]\n        Output: 16\n        Explanation: Any subsequence of this array is arithmetic.\n        \n        \u00a0\n        Constraints:\n        \n        1\u00a0 <= nums.length <= 1000\n        -231 <= nums[i] <= 231 - 1\n        \n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        ",
        "JavaScript": "/**\n * Given an integer array nums, return the number of all the arithmetic subsequences of nums.\n * A sequence of numbers is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.\n * \n * For example, [1, 3, 5, 7, 9], [7, 7, 7, 7], and [3, -1, -5, -9] are arithmetic sequences.\n * For example, [1, 1, 2, 5, 7] is not an arithmetic sequence.\n * \n * A subsequence of an array is a sequence that can be formed by removing some elements (possibly none) of the array.\n * \n * For example, [2,5,10] is a subsequence of [1,2,1,2,4,1,5,10].\n * \n * The test cases are generated so that the answer fits in 32-bit integer.\n * \u00a0\n * Example 1:\n * \n * Input: nums = [2,4,6,8,10]\n * Output: 7\n * Explanation: All arithmetic subsequence slices are:\n * [2,4,6]\n * [4,6,8]\n * [6,8,10]\n * [2,4,6,8]\n * [4,6,8,10]\n * [2,4,6,8,10]\n * [2,6,10]\n * \n * Example 2:\n * \n * Input: nums = [7,7,7,7,7]\n * Output: 16\n * Explanation: Any subsequence of this array is arithmetic.\n * \n * \u00a0\n * Constraints:\n * \n * 1\u00a0 <= nums.length <= 1000\n * -231 <= nums[i] <= 231 - 1\n * \n * @param {number[]} nums\n * @return {number}\n */\nvar numberOfArithmeticSlices = function(nums) {\n    \n};"
    }
}